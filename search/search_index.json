{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>We're really glad you're reading this, because we would love to have more developers contribute to this project! If you're passionate about making this project better, you're in the right place.</p>"},{"location":"CONTRIBUTING/#before-contributing","title":"Before contributing","text":"<p>If you encounter a bug or think of a useful feature, please create a new issue. Creating an issue before jumping into code ensures we can discuss it and determine whether it aligns with the direction of this project.</p> <p>If you want to contribute to the project, regardless of whether it's a small bug fix or correcting a typo, please feel free to do so. Any help goes a long way! Also, contributions aren't necessarily all code related. Other contributions can be in the form of issues, pull requests, discussions, etc.</p>"},{"location":"CONTRIBUTING/#got-a-question-or-problem","title":"Got a question or problem?","text":"<p>For quick questions there's no need to open an issue as you can reach us on GitHub Discussions.</p>"},{"location":"CONTRIBUTING/#reporting-a-bug","title":"Reporting a bug","text":"<p>Bugs are tracked as GitHub issues. Search open issues to see if someone else has reported a similar bug. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p> <p>When creating a new issue, please ensure the issue is clear and include additional details to help maintainers reproduce it:</p> <ul> <li>Use a clear and descriptive title for the issue to identify the problem.</li> <li>Describe the exact steps which reproduce the problem in as many details as possible.</li> <li>Provide specific examples to demonstrate the steps. Include links to files, or copy/pasteable snippets. If you're providing snippets in the issue, use Markdown code blocks.</li> <li>Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior.</li> <li>Explain which behavior you expected to see instead and why.</li> <li>Include screenshots and animated GIFs where possible.</li> </ul>"},{"location":"CONTRIBUTING/#sign-off-your-commits","title":"Sign-off your commits","text":"<p>A sign-off message in the following format is required on each commit in the pull request:</p> <pre><code>This is my commit message\n\nSigned-off-by: First_Name Last_Name &lt;My_Name@example.com&gt;\n</code></pre> <p>The text can either be manually added to your commit body, or you can add either <code>-s</code> or <code>--signoff</code> to your usual git commit commands.</p>"},{"location":"CONTRIBUTING/#creating-your-signoff","title":"Creating your signoff","text":"<p>Git has a <code>-s | --signoff</code> command-line option to append this automatically to your commit message:</p> <pre><code>git commit --signoff --message 'This is my commit message'\n</code></pre> <p>or</p> <pre><code>git commit -s -m \"This is my commit message\"\n</code></pre> <p>This will use your default git configuration which is found in <code>.git/config</code> and usually, it is the <code>username systemaddress</code> of the machine which you are using.</p> <p>To change this, you can use the following commands (Note these only change the current repo settings, you will need to add <code>--global</code> for these commands to change the installation default).</p> <p>Your name:</p> <pre><code>git config user.name \"First_Name Last_Name\"\n</code></pre> <p>Your email:</p> <pre><code>git config user.email \"My_Name@example.com\"\n</code></pre>"},{"location":"CONTRIBUTING/#how-to-amend-a-sign-off","title":"How to amend a sign-off","text":"<p>If you have authored a commit that is missing the signed-off-by line, you can amend your commits and push them to GitHub</p> <pre><code>git commit --amend --signoff\n</code></pre> <p>If you've pushed your changes to GitHub already you'll need to force push your branch after this with <code>git push -f</code>.</p>"},{"location":"LICENSE/","title":"License","text":"<p>Apache License</p> <p>Version 2.0, January 2004</p> <p>http://www.apache.org/licenses/</p> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:</p> <p>a. You must give any other recipients of the Work or Derivative Works a copy of this License; and</p> <p>b. You must cause any modified files to carry prominent notices stating that You changed the files; and</p> <p>c. You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and</p> <p>d. If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"hardware/","title":"Hardware description","text":"<p>This section of the documentation specifies and describes the nRF52840 Connect Kit mainly from a hardware point of view. </p>"},{"location":"hardware/#hardware-diagram","title":"Hardware diagram","text":"<p>The following figure illustrates the nRF52840 Connect Kit hardware diagram. The design is available in Chip antenna and U.FL receptacle options, both have most of the same components except the antenna interface.</p> <p></p>"},{"location":"hardware/#mechanical-dimensions","title":"Mechanical dimensions","text":"<p>nRF52840 Connect Kit is a single sided 55.88mm x 20.32mm (2.2\" x 0.8\") 1mm thick PCB with a USB Type-C port and dual castellated/through-hole pins.</p> <p></p>"},{"location":"hardware/#power-supply","title":"Power supply","text":"<p>nRF52840 Connect Kit can be powered by either the USB-C port or alternatively VSYS pin with wide input voltage range (1.8-5.5V). An on-board buck-boost converter (TPS63802) provides 3V3 to the nRF52840 SoC and all other peripherals.</p> <p>The following figure illustrates the power supply circuitry:</p> <p></p> <p>VBUS is the 5V input from the USB-C port. There is a Schottky diode between VBUS and VSYS, which adds flexibility by allowing power ORing of different supplies into VSYS.</p> <p>Set 3V3_EN <code>HIGH</code> to enable 3V3 output and <code>LOW</code> to disable 3V3 output. This pin has a pull-up resistor (100KOhm) and can be tied to GND to place the board in Power-Down mode.</p> <p>Set MODE <code>LOW</code> for power save mode and <code>HIGH</code> for forced PWM mode. This pin is tied to P1.13 with a pull-down resistor (100KOhm).</p> <p>How to power the board?</p> <p>nRF52840 Connect Kit has simple and flexible power management with various options for easily powering the board from USB-C, external supplies or batteries.</p> Using USB-C portFeeding VSYS directlyFeeding VSYS via a Schottky diodeFeeding VSYS via a P-MOSFETUsing a battery charger <p>This is the simplest way to power the board, which will power VSYS (and therefore the system) from the 5V USB VBUS voltage, through an internal Schottky diode (so VSYS becomes VBUS minus the Schottky diode forward voltage).</p> <p></p> <p>If the USB-C port is not going to be used, it is safe to power the board by directly connecting VSYS to your preferred power source (in the range 1.8V to 5.5V).</p> <p></p> <p>To safely add a second power source to the board, simply feed VSYS through an external Schottky diode.</p> <p></p> <p>An improved way to power from a second source is using an external P-MOSFET to replace the Schottky diode as shown in the following figure.</p> <p></p> <p>nRF52840 Connect Kit can be also used with a battery charger with power path manager which will automatically and seamlessly switch between the input source and the battery power.</p> <p></p>"},{"location":"hardware/#voltage-measurement","title":"Voltage measurement","text":"<p>nRF52840 Connect Kit uses one ADC input (AIN0) and a voltage divider to measure the voltage of VSYS. AIN0 measures the voltage over the lower resistor and P1.14 is used to enable the voltage measurement. The voltage measurement circuitry is shown in the following figure:</p> <p></p>"},{"location":"hardware/#general-purpose-ios","title":"General purpose I/Os","text":"<p>There are up to 32 multi-function General Purpose I/Os (7 can be used as ADC inputs) available on the header pins. These GPIOs are powered from the on-board 3.3V rail, and should be used for 3.3V logic level. Any GPIO can be mapped to a digital peripheral (such as UART, SPI, TWI, PDM, I2S, QSPI, PWM and QDEC) for layout flexibility.</p> <p>The following figure illustrates the GPIOs pinout:</p> <p></p>"},{"location":"hardware/#buttons-and-leds","title":"Buttons and LEDs","text":"<p>There are two buttons, one Green LED and one RGB LED connected to dedicated GPIOs on the nRF52840 SoC. The following table shows the Button and LED connections:</p> Part GPIO Active state USER Button <code>P1.0</code> <code>LOW</code> RESET Button <code>P0.18</code> <code>LOW</code> Green LED <code>P1.15</code> <code>LOW</code> RGB LED - Red <code>P1.10</code> <code>LOW</code> RGB LED - Green <code>P1.11</code> <code>LOW</code> RGB LED - Blue <code>P1.12</code> <code>LOW</code>"},{"location":"hardware/#external-memory","title":"External memory","text":"<p>The nRF52840 SoC has access to an additional 64 Mb of flash memory (MX25R6435F) which is a multi-I/O memory supporting both regular Serial Peripheral Interface (SPI) and Quad SPI (QSPI).</p> <p>The memory is connected to the nRF52840 SoC using the following GPIOs:</p> GPIO MX25R6435F Pin <code>P0.17</code> <code>CS#</code> <code>P0.19</code> <code>SCLK</code> <code>P0.20</code> <code>SIO0/SI</code> <code>P0.21</code> <code>SIO1/SO</code> <code>P0.22</code> <code>SIO2/WP#</code> <code>P0.23</code> <code>SIO3/HOLD#</code>"},{"location":"hardware/#24ghz-antenna","title":"2.4GHz antenna","text":"<p>nRF52840 Connect Kit has Chip antenna and U.FL receptacle options available to support various applications:</p> <ul> <li>For most applications, Chip antenna can offer excellent wireless performance.</li> <li>For some applications (for example, metallic enclosure or metallized plastic is used), using U.FL receptacle with an external antenna is a better choice, which can offer the best wireless performance.</li> </ul> <p></p>"},{"location":"hardware/#nfc-antenna-interface","title":"NFC antenna interface","text":"<p>nRF52840 Connect Kit supports a Near Field Communication (NFC) tag. NFC uses two pins (NFC1 and NFC2) to connect the antenna. These pins are shared with GPIOs (P0.09 and P0.10).</p> <p>An NFC antenna is a coil inductor, and together with capacitors to ground, they form a parallel resonant LC tank. Since the active device operates at 13.56 MHz, the passive device antenna should also resonate at that frequency. </p> <p>The following figure shows the antenna and the parallel capacitors forming an LC tank circuit. The parallel capacitors, Ctune1 and Ctune2 are pre-mounted with 100pF capacitors.</p> <p></p>"},{"location":"hardware/#debug-interface","title":"Debug interface","text":"<p>nRF52840 Connect Kit supports Arm Serial Wire Debug (SWD) port, which makes it possible to connect external debuggers for debugging and programming. The I/O voltage of SWD should be 3.3V.</p> <p>The following figure demonstrates how to connect an external debugger (for example, Pitaya-Link debug probe) for debugging:</p> <p></p> <p>The connections are listed in the table below:</p> Pitaya-Link Wire nRF52840 Connect Kit <code>3V3</code> <code>VSYS</code> <code>GND</code> <code>GND</code> <code>RESET</code> <code>RESET</code> <code>SWDCLK</code> <code>SWDCLK</code> <code>SWDIO</code> <code>SWDIO</code>"},{"location":"introduction/","title":"nRF52840 Connect KitRapid prototyping kit for your next connected projects","text":""},{"location":"introduction/#description","title":"Description","text":"<p>nRF52840 Connect Kit is an open-source prototyping kit designed for connected projects. It is built using the nRF52840 SoC, which has protocol support for Bluetooth LE, Bluetooth mesh, Thread, Zigbee, 802.15.4, ANT and 2.4 GHz proprietary stacks. It provides Arm TrustZone\u00ae CryptoCell cryptographic unit as well as numerous peripherals such as USB 2.0, NFC-A, GPIO, UART, SPI, TWI, PDM, I2S, QSPI, PWM, ADC, QDEC to support a wide range of applications.</p> <p>The design is available in an easy-to-use form factor with USB-C and 40 pin DIP/SMT type, including up to 32 multi-function GPIO pins (7 can be used as ADC inputs) and Serial Wire Debug (SWD) port. It features RGB LED, Buttons, external 64 Mbit QSPI flash and flexible power management with various options for easily powering the unit from USB-C, external supplies or batteries, and also has Chip antenna and U.FL receptacle options to support various wireless scenarios.</p> <p>nRF52840 Connect Kit supports nRF Connect SDK, which integrates the Zephyr RTOS, protocol stacks, samples, hardware drivers and much more. We also offer Python support, allowing you access hardware-specific functionality and peripherals with Python programming language.</p> <p></p>"},{"location":"introduction/#key-features","title":"Key Features","text":"<ul> <li> <p>Nordic Semiconductor nRF52840 SoC</p> <ul> <li>64 MHz Arm\u00ae Cortex-M4 with FPU</li> <li>1 MB Flash + 256 KB RAM</li> <li>Bluetooth LE, Bluetooth mesh, Thread, Zigbee, 802.15.4, ANT and 2.4 GHz proprietary</li> <li>Arm TrustZone\u00ae Cryptocell 310 Security Subsystem</li> <li>2.4 GHz Transceiver with +8 dBm TX Power</li> <li>GPIO, UART, SPI, TWI(I2C), PDM, I2S, QSPI, PWM, QDEC, 12-bit ADC support</li> <li>Integrated USB 2.0 Full-speed Controller</li> <li>Integrated NFC-A Tag</li> </ul> </li> <li> <p>Ultra low power 64 Mbit QSPI flash memory</p> </li> <li>User programmable RBG LED and Buttons</li> <li>Up to 32 multi-function General Purpose IOs (7 can be used as ADC inputs)</li> <li>Arm Serial Wire Debug (SWD) port via edge pins</li> <li>Flexible power management with various options for easily powering the unit </li> <li>Wide input voltage range: 1.8 V to 5.5 V, output 3.3V and up to 2A when Input \u2265 2.3 V</li> <li>3.3V IO Operating Voltage</li> <li>Reversible USB-C connector</li> <li>Available in Chip antenna and U.FL receptacle options</li> <li>40 pin 55.88mm x 20.32mm (2.2\" x 0.8\") DIP/SMT form factor</li> <li>Shipped with UF2 Bootloader supporting Drag-and-drop programming over USB drive</li> <li>Built on open source, supporting nRF Connect SDK, Zephyr RTOS, Python, etc.</li> </ul>"},{"location":"introduction/#whats-in-the-box","title":"What's in the box","text":"Part Quantity nRF52840 Connect Kit board 1 2.4 GHz Cabled PCB Antenna1 1 20 Pin 2.54mm THT Pin Header 2 <ol> <li> <p>This part is only available for U.FL receptacle option\u00a0\u21a9</p> </li> </ol>"},{"location":"out-of-box-experience/","title":"Out of box experiencenRF52840 Connect Kit Quick Start Guide","text":""},{"location":"out-of-box-experience/#introduction","title":"Introduction","text":"<p>This guide details the nRF52840 Connect Kit out of box experience. The kit is pre-programmed with a Bluetooth Low Energy Connectivity firmware that allows using nRF Connect Bluetooth Low Energy app to demonstrate Bluetooth Low Energy connectivity.</p>"},{"location":"out-of-box-experience/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with nRF Connect for Mobile installed</li> <li>nRF Connect Bluetooth Low Energy 4.0.1 or later</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"out-of-box-experience/#installing-the-nrf-connect-bluetooth-low-energy","title":"Installing the nRF Connect Bluetooth Low Energy","text":"<p>The nRF Connect Bluetooth Low Energy app is an easy-to-use cross-platform application for Bluetooth Low Energy connectivity testing. Choose your Desktop platform and select version (latest released version recommended) to download:</p> <p>Download</p> <p>After starting the nRF Connect Bluetooth Low Energy app, the application window is displayed.</p> <p></p>"},{"location":"out-of-box-experience/#installing-the-nrf-connect-for-mobile","title":"Installing the nRF Connect for Mobile","text":"<p>nRF Connect for Mobile app is a powerful generic tool that allows you to scan and explore your Bluetooth Low Energy devices and communicate with them.</p> <p> </p>"},{"location":"out-of-box-experience/#connecting-the-board","title":"Connecting the board","text":"<p>The nRF Connect Bluetooth Low Energy app requires a serial port connection to nRF52840 Connect Kit. The board is controlled by the app which sends serialized commands to it over a serial port.</p> <p>To connect the board, complete the following steps:</p> <ol> <li> <p>Connect nRF52840 Connect Kit to the computer by using the USB-C Cable. When the USB device is started, the RGB LED turns blue.</p> <p></p> </li> <li> <p>Open the nRF Connect Bluetooth Low Energy app, in the navigation bar, click on the SELECT DEVICE menu.</p> </li> <li> <p>Select a device by clicking on its name - nRF52840 Connect Kit in the drop-down list.</p> </li> </ol> <p></p>"},{"location":"out-of-box-experience/#establishing-bluetooth-low-energy-connections","title":"Establishing Bluetooth Low Energy connections","text":"<p>The nRF Connect Bluetooth Low Energy app can establish and maintain up to eight simultaneous Bluetooth Low Energy connections.</p> <p>To connect to devices, complete the following steps:</p> <ol> <li> <p>To scan for nearby Bluetooth devices, click the Start scan button in the Discovered devices view.</p> <p>The advertising devices start to appear in a list in the Discovered devices view. Each entry in the list shows the name, address, and RSSI of the received advertising packet. </p> </li> <li> <p>To establish a Bluetooth connection with a peer device, click the Connect button associated with the device.</p> <p></p> <p>When the connection has been established, a new peripheral device appears in the Connection Map, to the right of the local device. The nRF Connect Bluetooth Low Energy app automatically performs an initial service discovery. The discovered services are listed below the connected device.</p> </li> </ol>"},{"location":"out-of-box-experience/#viewing-service-details","title":"Viewing service details","text":"<p>The nRF Connect Bluetooth Low Energy app can discover and display services, characteristics, and descriptors of a connected peer device's attribute table.</p> <ul> <li>To view the handle and UUID of an attribute, move the mouse pointer over the attribute name. A hover text is displayed.</li> <li>To view the characteristics of a service, click the Expand/collapse icon  .</li> <li>To view descriptors, expand the characteristics.</li> <li>To configure the peer device to start sending notifications, click the Toggle notifications icon  . When a device receives a notification, the corresponding attribute is highlighted, and its value is updated.</li> </ul> <p></p>"},{"location":"out-of-box-experience/#setting-up-advertising","title":"Setting up advertising","text":"<p>The nRF Connect Bluetooth Low Energy app can also enable the local device to operate as a peripheral that can send connectable advertising packets. The contents of the advertising packets can be configured in the advertising setup.</p> <p>To start sending advertising packets, complete the following steps:</p> <ol> <li>Click the local Device options icon  .</li> <li> <p>Specify the contents of the advertising packets:</p> <ol> <li>To display the Advertising setup dialog, click Advertising setup.</li> <li>From the AD type drop-down menu, select an AD type.</li> <li>In the Value field, add a data value.</li> <li>Select Add to advertising data or Add to scan response.</li> <li>Repeat until all wanted fields are present.</li> <li>Click Apply, then click Close.</li> </ol> <p></p> </li> <li> <p>To start advertising the device, click Start advertising.</p> </li> <li> <p>Open nRF Connect for Mobile app, pull down to scan the device:</p> <p></p> </li> </ol>"},{"location":"out-of-box-experience/#next-steps","title":"Next steps","text":"<p>Now, you have finished the nRF52840 Connect Kit out of box experience, it's time to learn more essential developer guides.</p> <p>To learn how to program the nRF52840 Connect Kit, check out this guide:</p> <ul> <li>How to program the nRF52840 Connect Kit</li> </ul> <p>You can also make the nRF52840 Connect Kit as a Bluetooth LE or IEEE 802.15.4-based (such as Thread and ZigBee) packet sniffer, which can help identify and fix issues by allowing a view of what is happening on-air. Follow these guides to setup:</p> <ul> <li>nRF Sniffer for Bluetooth LE</li> <li>nRF Sniffer for 802.15.4</li> </ul> <p>To quickly get started with the nRF Connect SDK development, check the guide below for instructions:</p> <ul> <li>Develop with nRF Connect SDK</li> </ul> <p>nRF52840 Connect Kit also offers Python support, allowing you access hardware-specific functionality and peripherals with Python programming language:</p> <ul> <li>Code in Python</li> </ul>"},{"location":"purchase/","title":"Purchase","text":""},{"location":"purchase/#buy-online","title":"Buy Online","text":"<p>nRF52840 Connect Kit is available on the following channels (click to go directly to the product):</p> <p> </p>"},{"location":"purchase/#request-large-volume-pricing","title":"Request Large Volume Pricing","text":"<p>Thank you for your interest in purchasing large volume from Makerdiary. In order to help you more efficiently, please contact our sales: store@makerdiary.com</p> <p>Request Quote</p>"},{"location":"purchase/#design-customization","title":"Design &amp; Customization","text":"<p>We are ready to customize our hardware and firmware to better meet your solution's needs. Many of our platforms are prepared for customization.</p> <p>If you would like to do some serious business, feel free to contact us and we'll reply before you know it: support@makerdiary.com</p> <p>Design Services</p>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#technical-documentation","title":"Technical documentation","text":"<ul> <li>nRF52840 Connect Kit Product Brief</li> <li>nRF52840 Connect Kit Out-of-box Experience</li> <li>How to program the nRF52840 Connect Kit</li> <li>Develop with nRF Connect SDK &amp; Zephyr RTOS</li> <li>How to Code in Python</li> <li>nRF Sniffer for Bluetooth LE</li> <li>nRF Sniffer for 802.15.4</li> </ul>"},{"location":"resources/#hardware-resource","title":"Hardware resource","text":"<ul> <li>nRF52840 Connect Kit Quick Start Guide</li> <li>nRF52840 Connect Kit Hardware Description</li> <li>nRF52840 Connect Kit Schematic V1.0</li> <li>nRF52840 Connect Kit 3D CAD STEP Models</li> </ul>"},{"location":"resources/#regulatory-compliance","title":"Regulatory &amp; Compliance","text":"<ul> <li>FCC Supplier's Declaration of Conformity (SDoC)</li> <li>EU Declaration of Conformity (DoC)</li> <li>RoHS &amp; REACH Declaration of Conformity</li> </ul>"},{"location":"revision-history/","title":"Revision history","text":""},{"location":"revision-history/#hardware","title":"Hardware","text":""},{"location":"revision-history/#HW_V1.0","title":"V1.0 April 19, 2022","text":"<ul> <li>The first public release</li> </ul>"},{"location":"revision-history/#documentation","title":"Documentation","text":""},{"location":"revision-history/#DOC_V1.0.0","title":"V1.0.0 March 31, 2023","text":"<ul> <li>Initial release</li> </ul>"},{"location":"blog/introducing-circuitpython/","title":"Introducing CircuitPython","text":"<p>makerdiary  April 27, 2023 \u00b7  5 min read </p>"},{"location":"blog/introducing-circuitpython/#what-is-circuitpython","title":"What is CircuitPython?","text":"<p>CircuitPython is a programming language designed to simplify experimenting and learning to program on low-cost microcontroller boards. It makes getting started easier than ever with no upfront desktop downloads needed. Once you get your board set up, open any text editor, and get started editing code. It's that simple.</p> <p>CircuitPython is an implementation of Python, which is a high-level programming language which means it's designed to be easier to read, write and maintain. It supports modules and packages which means it's easy to reuse your code for other projects. It has a built in interpreter which means there are no extra steps, like compiling, to get your code to work. And of course, it is Open Source Software which means it's free for anyone to use, modify or improve upon.</p>"},{"location":"blog/introducing-circuitpython/#why-circuitpython","title":"Why CircuitPython?","text":"<p>CircuitPython is a fork of MicroPython, and offers unified Python core APIs and a growing list of 300+ device libraries and drivers that work with it. You can see differences from MicroPython.</p> <p>Here is some reasons to use CircuitPython:</p> <ul> <li>You want to get up and running quickly. Create a file, edit your code, save the file, and it runs immediately. There is no compiling, no downloading and no uploading needed.</li> <li>You're new to programming. CircuitPython is designed with education in mind. It's easy to start learning how to program and you get immediate feedback from the board.</li> <li>Easily update your code. Since your code lives on the disk drive, you can edit it whenever you like, you can also keep multiple files around for easy experimentation.</li> <li>The serial console and REPL. These allow for live feedback from your code and interactive programming. File storage. The internal storage for CircuitPython makes it great for data-logging, playing audio clips, and otherwise interacting with files.</li> <li>Strong hardware support. CircuitPython has builtin support for microcontroller hardware features like digital I/O pins, hardware buses (UART, I2C, SPI), audio I/O, and other capabilities. There are also many libraries and drivers for sensors, breakout boards and other external components.</li> <li>It's Python! Python is the fastest-growing programming language. It's taught in schools and universities. CircuitPython is almost-completely compatible with Python. It simply adds hardware support.</li> </ul>"},{"location":"blog/introducing-circuitpython/#how-to-get-started","title":"How to get started?","text":"<p>To use CircuitPython, you need to choose a microcontroller board well supported by CircuitPython. There are 300+ boards that can run CircuitPython.</p> <p>Here we have ported CircuitPython to our nRF52840 Connect Kit and offer an extensive set of documentation and samples to help you get started quickly:</p> <p>Getting Started with CircuitPython</p>"},{"location":"blog/introducing-ncs/","title":"Introducing nRF Connect SDK","text":"<p>makerdiary  May 4, 2023 \u00b7  10 min read </p>"},{"location":"blog/introducing-ncs/#overview","title":"Overview","text":"<p>nRF Connect SDK is a scalable and unified software development kit for building products based on Nordic Semiconductor's nRF52, nRF53, nRF70 and nRF91 Series wireless devices. It offers developers an extensible framework for building size-optimized software for memory-constrained devices as well as powerful and complex software for more advanced devices and applications.</p> <p>It integrates the Zephyr Real-Time Operating System (RTOS) and a wide range of complete applications, samples, and protocol stacks such as Bluetooth Low Energy, Bluetooth mesh, Matter, Thread/Zigbee and LTE-M/NB-IoT/GPS, TCP/IP. It also includes middleware such as CoAP, MQTT, LwM2M, various libraries, hardware drivers, Trusted Firmware-M for security, and a secure bootloader (MCUBoot).</p> <p>The following figure illustrates the architecture of the nRF Connect SDK, where Zephyr RTOS and third-party components (Ex: MCUBoot, Trusted Firmware-M) are shown in dark blue:</p> <p></p>"},{"location":"blog/introducing-ncs/#about-zephyr-rtos","title":"About Zephyr RTOS","text":"<p>Zephyr RTOS is an open-source real-time operating system for connected and resource-constrained embedded devices. It includes a scheduler that ensures predictable/deterministic execution patterns and abstracts out the timing requirements. It also comes with a rich set of fundamental libraries and middleware that simplifies development and helps reduce a product\u2019s time to market. Zephyr RTOS is highly configurable and enables scalable configurations from very small configurations for memory-constrained devices (minimum 8 kilobytes, for example, simple LED blinking application) to powerful, feature-rich, high-processing power devices (multiple MBs of memory) with large memory configurations.</p> <p>Zephyr RTOS</p>"},{"location":"blog/introducing-ncs/#how-nrf-connect-sdk-code-is-organized","title":"How nRF Connect SDK code is organized","text":"<p>The nRF Connect SDK offers a single code base for all of Nordic\u2019s devices and software components. It simplifies porting modules, libraries, and drivers from one application to another, thus reducing development time. By enabling developers to pick and choose the essential software components for their application, high memory efficiency is guaranteed. The nRF Connect SDK is publicly hosted on GitHub.</p> <p>Internally, the nRF Connect SDK code is organized into four main repositories:</p> <ul> <li>nrf \u2013 Applications, samples, connectivity protocols (Nordic)</li> <li>nrfxlib \u2013 Common libraries and stacks (Nordic)</li> <li>Zephyr \u2013 RTOS &amp; Board configurations (open source)</li> <li>MCUBoot \u2013 Secure Bootloader (open source)</li> </ul> <p>In addition to the four main repositories, there are also other repositories like the TrustedFirmware-M repository and the Matter repository.</p>"},{"location":"blog/introducing-ncs/#tools-and-configuration","title":"Tools and configuration","text":"<p>The figure below visualizes the toolchain in the nRF Connect SDK, which is based on the Zephyr toolchain. You can see a set of different tools, each playing a role in the creation of an application, from configuring the system to building it.</p> <p></p> <p>Kconfig generates definitions that configure the whole system, for example which wireless protocol or which libraries to include in your application. Devicetree describes the hardware. CMake then uses the information from Kconfig and the devicetree to generate build files, which Ninja will use to build the program. The GCC compiler system is used to create the executables.</p> <p>This high decoupling of the source code (<code>*.c</code>) and the configuration system through Kconfig (<code>*.conf</code>) and the hardware description system through devicetree (<code>*.dts</code>) makes it easy to use the same application source code on different hardware and with different configurations with minimal changes. This has a huge impact on the ease of portability and maintainability.</p> <p></p>"},{"location":"blog/introducing-ncs/#next-steps","title":"Next steps","text":"<p>Now that we have an understanding of the content and structure of the nRF Connect SDK, let\u2019s move to the developer guides which will step you through the basics of nRF Connect SDK development and show you how to implement typical use cases with Nordic Semiconductor libraries and drivers on nRF52840 Connect Kit.</p> <p>nRF Connect SDK Developer Guides</p>"},{"location":"blog/nrf52840-connectkit-is-here/","title":"nRF52840 Connect Kit is Here!","text":"<p>makerdiary  April 20, 2023 \u00b7  3 min read </p> <p>We are excited to announce that nRF52840 Connect Kit is now available! It's a new member of our nRF52840-based prototyping kit family. It comes in a more mainstream form factor with USB-C and 40 pin DIP/SMT type. A new power architecture is introduced to support various options for easily powering the unit from USB, external supplies or batteries. We will also offer Chip antenna or U.FL receptacle option for selection.</p> <p></p> <p>With nRF52840 Connect Kit you can quickly and easily build your next connected project supporting Bluetooth LE, Bluetooth mesh, NFC, Thread, Zigbee, 802.15.4, ANT and 2.4 GHz proprietary stacks. Easy-to-use form factor, USB-C, 64 Mbit QSPI flash, flexible power management and a rich set of features enable designs to meet a wide range of applications.</p> <p>About nRF52840</p> <p>The nRF52840 SoC is the most advanced member of the nRF52 Series. It meets the challenges of sophisticated applications that need protocol concurrency and a rich and varied set of peripherals and features. It offers generous memory availability for both Flash and RAM, which are prerequisites for such demanding applications.</p> <p>The nRF52840 is fully multiprotocol capable with full protocol concurrency. It has protocol support for Bluetooth LE, Bluetooth mesh, Thread, Zigbee, 802.15.4, ANT and 2.4 GHz proprietary stacks.</p> <p>nRF52840 Connect Kit has support for Nordic Semi's nRF Connect SDK, which integrates the Zephyr RTOS, protocol stacks, samples, hardware drivers and much more. We also offer Python support, allowing you access hardware-specific functionality and peripherals with Python programming language.</p> <p>In addition, we offer an extensive set of documentation such as out of box experience, getting started and developer guides, which can help you save big by reducing development effort.</p> <p>Interested in our brand new nRF52840 Connect Kit? You can get it from the official store or refer to our wiki page for more technical resources.</p>"},{"location":"guides/ble-sniffer/","title":"nRF Sniffer for Bluetooth LE","text":""},{"location":"guides/ble-sniffer/#introduction","title":"Introduction","text":"<p>nRF Sniffer for Bluetooth LE is a useful tool for debugging and learning about Bluetooth Low Energy applications.</p> <p>The nRF Sniffer for Bluetooth LE allows near real-time display of Bluetooth LE packets. This helps the developer to identify and fix issues by allowing a view of what is happening on-air.</p>"},{"location":"guides/ble-sniffer/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>Supported operating systems:<ul> <li>Windows 10</li> <li>64-bit OS X/macOS 10.6 or later</li> <li>Linux (check the Wireshark prerequisites for version compatibility)</li> </ul> </li> <li>Wireshark v3.4.7 or later</li> <li>Python v3.6 or later</li> </ul>"},{"location":"guides/ble-sniffer/#get-involved","title":"Get Involved","text":"<p>The following sections explain how to set up the nRF Sniffer for Bluetooth LE and help you get moving with sniffing:</p> <ul> <li>Installation</li> <li>Running the nRF Sniffer</li> <li>nRF Sniffer usage</li> <li>Common sniffing actions</li> </ul>"},{"location":"guides/ble-sniffer/#reference","title":"Reference","text":"<ul> <li>nRF Sniffer for Bluetooth LE User Guide v4.1.x</li> <li>Wireshark website</li> </ul>"},{"location":"guides/ble-sniffer/actions/","title":"Common sniffing actions","text":"<p>The nRF Sniffer for Bluetooth LE can help you explore and debug Bluetooth Low Energy communication in a number of typical scenarios.</p>"},{"location":"guides/ble-sniffer/actions/#sniffing-advertisements-from-all-nearby-devices","title":"Sniffing advertisements from all nearby devices","text":"<p>Use the nRF Sniffer for Bluetooth LE to see advertisements from all nearby devices.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Ensure that All advertising devices is selected in the device list.</li> </ol>"},{"location":"guides/ble-sniffer/actions/#sniffing-advertisement-packets-involving-a-single-peripheral","title":"Sniffing advertisement packets involving a single Peripheral","text":"<p>Use the nRF Sniffer for Bluetooth LE to see advertisement packets, scan requests, and scan responses to and from a single device.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Select your device from the device list.</li> </ol>"},{"location":"guides/ble-sniffer/actions/#sniffing-a-connection-involving-a-single-peripheral","title":"Sniffing a connection involving a single Peripheral","text":"<p>Use the nRF Sniffer for Bluetooth LE to sniff a connection between a specific Peripheral and a Central.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Select your device from the device list.</li> <li>Connect the Central to the Peripheral.</li> </ol>"},{"location":"guides/ble-sniffer/actions/#sniffing-the-pairing-procedure-of-a-connection","title":"Sniffing the pairing procedure of a connection","text":"<p>Use the nRF Sniffer for Bluetooth to sniff an encrypted connection between paired devices by sniffing the pairing procedure.</p> <p>Note</p> <p>If the board running the nRF Sniffer firmware is reset, stored bond information is lost.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Select your device from the device list.</li> <li> <p>Enter the credentials for pairing. The procedure depends on the type of encryption.</p> <ul> <li> <p>For connections that use legacy pairing with Just Works:</p> <ol> <li>Initiate pairing between the devices if it does not happen automatically.</li> </ol> <p>No further action is required.</p> </li> <li> <p>For connections that use legacy pairing with a passkey:</p> <ol> <li>Initiate pairing between the devices if it does not happen automatically.</li> <li>Select Legacy Passkey as input key and type the 6-digit passkey that is displayed on either the Central or the Peripheral into the input field in Wireshark.</li> <li>Press Enter.</li> <li>Enter the passkey into the other device.</li> </ol> </li> <li> <p>For connections that use legacy pairing with OOB:</p> <ol> <li>Before the devices initiate pairing, select Legacy OOB data as input key and type the OOB key in big-endian, hexadecimal format with a leading <code>0x</code> into the input field in Wireshark.</li> <li>Press Enter.</li> <li>Connect the Central to the Peripheral.</li> <li>Initiate pairing between the devices if it does not happen automatically.</li> </ol> </li> <li> <p>For connections that use LE Secure Connections in debug mode:</p> <ol> <li>Enable Secure Connections debug mode on one or both of the devices.</li> <li>Initiate pairing between the devices if it does not happen automatically.</li> </ol> <p>In debug mode, the connection uses the debug keys specified in the Bluetooth Core Specification. The nRF Sniffer uses the same keys to decrypt the encrypted packets.</p> </li> <li> <p>For connections that use LE Secure Connections with a private key:</p> <ol> <li>Before the devices initiate pairing, select SC Private Key as input key and type the 32-byte DiffieHellman private key of your device in big-endian, hexadecimal format with a leading <code>0x</code> into the input field in Wireshark.</li> <li>Initiate pairing between the devices if it does not happen automatically.</li> </ol> </li> </ul> </li> </ol>"},{"location":"guides/ble-sniffer/actions/#sniffing-a-connection-between-bonded-devices","title":"Sniffing a connection between bonded devices","text":"<p>Use the nRF Sniffer for Bluetooth to sniff an encrypted connection between bonded devices. If the nRF Sniffer has previously successfully sniffed the pairing procedure, it remembers the LTK needed to decrypt the connection. Otherwise, you must provide the LTK.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Select your device from the device list.</li> <li> <p>Enter the LTK for the bond.</p> <ul> <li> <p>For connections that have an existing legacy bond, select Legacy LTK as input key and type the legacy LTK key in big-endian, hexadecimal format with a leading <code>0x</code> into the input field in Wireshark.</p> </li> <li> <p>For connections that have an existing LE Secure Connections bond, select SC LTK as input key and type the LE Secure Connections LTK key in big-endian, hexadecimal format with a leading <code>0x</code> into the input field in Wireshark.</p> </li> </ul> </li> <li> <p>Initiate encryption between the devices (pairing is not performed when a bond exists).</p> </li> </ol>"},{"location":"guides/ble-sniffer/actions/#sniffing-advertisement-packets-involving-a-privacyenabled-peripheral","title":"Sniffing advertisement packets involving a privacyenabled Peripheral","text":"<p>Use the nRF Sniffer for Bluetooth LE to see advertisement packets, scan requests, and scan responses to and from a single privacy-enabled device. If the nRF Sniffer has previously successfully sniffed the pairing procedure, it remembers the IRK needed to resolve the identity of the device. Otherwise, you must provide the IRK.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Enter the IRK for the device. In Wireshark, select IRK as the input key and type the IRK in big-endian, hexadecimal format with a leading <code>0x</code> into the input field.</li> <li>Select your device or Follow IRK from the device list.</li> </ol>"},{"location":"guides/ble-sniffer/actions/#sniffing-advertisement-packets-involving-a-periodic-advertiser","title":"Sniffing advertisement packets involving a Periodic Advertiser","text":"<p>Use the nRF Sniffer for Bluetooth LE to see periodic advertise data from a Periodic Advertiser. If the advertiser has periodic advertising sync information, the sniffer follows the periodic advertising train.</p> <ol> <li>Run the nRF Sniffer (if not already running).</li> <li>Select your device from the device list.</li> </ol>"},{"location":"guides/ble-sniffer/installation/","title":"Installing the nRF Sniffer","text":"<p>The nRF Sniffer for Bluetooth LE software consists of firmware that is programmed onto a nRF52840 Connect Kit and a capture plugin for Wireshark that records and analyzes the detected data.</p> <p>This section of the documentation explains how to install the nRF Sniffer for Bluetooth LE software.</p>"},{"location":"guides/ble-sniffer/installation/#programming-the-nrf-sniffer-firmware","title":"Programming the nRF Sniffer firmware","text":"<p>You must connect a nRF52840 Connect Kit running the nRF Sniffer firmware to your computer to be able to use the nRF Sniffer for Bluetooth LE.</p> <p>The nRF Sniffer firmware in <code>.uf2</code>-format is located in <code>firmware/ble_sniffer/</code>.</p> <p>Download the latest firmware and complete the following steps to flash the firmware:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>nrf_sniffer_for_bluetooth_le_&lt;version&gt;.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the nRF Sniffer will start running.</p> </li> </ol>"},{"location":"guides/ble-sniffer/installation/#installing-wireshark","title":"Installing Wireshark","text":"<p>To install Wireshark for your operating system, complete the following steps:</p> Windows/macOSUbuntu Linux <ol> <li>Go to the Wireshark download page.</li> <li>Click the release package for your operating system from the Stable Release list. The download starts automatically.</li> <li>Install the package.</li> </ol> <ol> <li>Download the Wireshark standard package or the latest stable PPA for Ubuntu Linux distribution from the Wireshark download page.</li> <li>Install the package on your computer.</li> <li>Answer <code>yes</code> when the installer asks you if non-superusers should be able to capture packets. This ensures that packet capture is available to all users in the wireshark system group.</li> <li>Add the correct user to the wireshark user group. For example, type <code>sudo usermod -a -G wireshark $USER</code>.</li> <li>Add the correct user to the dialout user group. For example, type <code>sudo usermod -a -G dialout $USER</code>.</li> <li>Restart your computer to apply the new user group settings.</li> </ol>"},{"location":"guides/ble-sniffer/installation/#installing-the-nrf-sniffer-capture-tool","title":"Installing the nRF Sniffer capture tool","text":"<p>The nRF Sniffer for Bluetooth LE software is installed as an external capture plugin in Wireshark.</p> <p>To install the nRF Sniffer capture tool, complete the following steps:</p> <ol> <li> <p>Install the Python requirements:</p> <ol> <li>Open a command window in the <code>tools/ble_sniffer/extcap/</code> folder.</li> <li> <p>Install the Python dependencies listed in <code>requirements.txt</code> by doing one of the following:</p> Windows with Python launcherWindows without Python launcherLinux/macOS <pre><code> py -3 -m pip install -r requirements.txt\n</code></pre> <pre><code>python -m pip install -r requirements.txt\n</code></pre> <pre><code>python3 -m pip install -r requirements.txt\n</code></pre> </li> <li> <p>Close the command window.</p> </li> </ol> </li> <li> <p>Copy the nRF Sniffer capture tool into Wireshark's folder for personal external capture plugins:</p> <ol> <li>Open Wireshark.</li> <li> <p>Go to Help &gt; About Wireshark (on Windows or Linux) or Wireshark &gt; About Wireshark (on macOS).</p> <p></p> </li> <li> <p>Select the Folders tab.</p> </li> <li> <p>Double-click the location for the Personal Extcap path to open this folder.</p> <p></p> </li> <li> <p>Copy the contents of the <code>tools/ble_sniffer/extcap/</code> folder into this folder.</p> <p></p> </li> </ol> </li> <li> <p>Make sure that the nRF Sniffer files can be run correctly:</p> <ol> <li>Open a command window in Wireshark's folder for personal external capture plugins.</li> <li> <p>Run the nRF Sniffer tool to list available interfaces.</p> WindowsLinux/macOS <pre><code>nrf_sniffer_ble.bat --extcap-interfaces\n</code></pre> <pre><code>./nrf_sniffer_ble.sh --extcap-interfaces\n</code></pre> <p>You should see a series of strings, similar to what is shown in the following:</p> <pre><code>extcap {version=4.1.1}{display=nRF Sniffer for Bluetooth LE}{help=https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Sniffer-for-Bluetooth-LE}\ncontrol {number=0}{type=selector}{display=Device}{tooltip=Device list}\ncontrol {number=1}{type=selector}{display=Key}{tooltip=}\ncontrol {number=2}{type=string}{display=Value}{tooltip=6 digit passkey or 16 or 32 bytes encryption key in hexadecimal starting with '0x', big endian format.If the entered key is shorter than 16 or 32 bytes, it will be zero-padded in front'}{validation=\\b^(([0-9]{6})|(0x[0-9a-fA-F]{1,64})|([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2}) (public|random))$\\b}\ncontrol {number=3}{type=string}{display=Adv Hop}{default=37,38,39}{tooltip=Advertising channel hop sequence. Change the order in which the sniffer switches advertising channels. Valid channels are 37, 38 and 39 separated by comma.}{validation=^\\s*((37|38|39)\\s*,\\s*){0,2}(37|38|39){1}\\s*$}{required=true}\ncontrol {number=7}{type=button}{display=Clear}{tooltop=Clear or remove device from Device list}\ncontrol {number=4}{type=button}{role=help}{display=Help}{tooltip=Access user guide (launches browser)}\ncontrol {number=5}{type=button}{role=restore}{display=Defaults}{tooltip=Resets the user interface and clears the log file}\ncontrol {number=6}{type=button}{role=logger}{display=Log}{tooltip=Log per interface}\nvalue {control=0}{value= }{display=All advertising devices}{default=true}\nvalue {control=0}{value=[00,00,00,00,00,00,0]}{display=Follow IRK}\nvalue {control=1}{value=0}{display=Legacy Passkey}{default=true}\nvalue {control=1}{value=1}{display=Legacy OOB data}\nvalue {control=1}{value=2}{display=Legacy LTK}\nvalue {control=1}{value=3}{display=SC LTK}\nvalue {control=1}{value=4}{display=SC Private Key}\nvalue {control=1}{value=5}{display=IRK}\nvalue {control=1}{value=6}{display=Add LE address}\nvalue {control=1}{value=7}{display=Follow LE address}\n</code></pre> </li> </ol> </li> <li> <p>Enable the nRF Sniffer capture tool in Wireshark:</p> <ol> <li> <p>Refresh the interfaces in Wireshark by selecting Capture &gt; Refresh Interfaces or pressing F5 . You should see that nRF Sniffer is displayed as one of the interfaces on the Wireshark capture screen.</p> <p></p> </li> <li> <p>Select View &gt; Interface Toolbars &gt; nRF Sniffer for Bluetooth LE to enable the nRF Sniffer interface.</p> </li> </ol> </li> </ol>"},{"location":"guides/ble-sniffer/installation/#adding-a-wireshark-profile-for-the-nrf-sniffer","title":"Adding a Wireshark profile for the nRF Sniffer","text":"<p>You can add a profile in Wireshark for displaying the data recorded by the nRF Sniffer for Bluetooth LE in a convenient way.</p> <p>To add the nRF Sniffer profile in Wireshark, complete the following steps:</p> <ol> <li>Go to Help &gt; About Wireshark (on Windows or Linux) or Wireshark &gt; About Wireshark (on macOS).</li> <li>Select the Folders tab.</li> <li>Double-click the location for the Personal configuration to open this folder.</li> <li>Copy the profile folder <code>tools/ble_sniffer/Profile_nRF_Sniffer_Bluetooth_LE</code> into the <code>profiles</code> subfolder of this folder.</li> <li>In Wireshark, select Edit &gt; Configuration Profiles....</li> <li> <p>Select Profile_nRF_Sniffer_Bluetooth_LE and click OK.</p> <p></p> </li> </ol>"},{"location":"guides/ble-sniffer/running-sniffer/","title":"Running the nRF Sniffer","text":"<p>To start sniffing, place the nRF52840 Connect Kit that runs the nRF Sniffer for Bluetooth LE firmware between the two devices that are communicating. Then open Wireshark and start recording packets.</p>"},{"location":"guides/ble-sniffer/running-sniffer/#setting-up-hardware","title":"Setting up hardware","text":"<p>Connect the nRF52840 Connect Kit to your computer. Then place it between the Central and Peripheral device that you want to sniff.</p> <p></p>"},{"location":"guides/ble-sniffer/running-sniffer/#wireshark-capture-setup","title":"Wireshark capture setup","text":"<p>When you open Wireshark, the Wireshark capture screen is displayed. It includes the Wireshark interface for managing packets that are captured, the nRF Sniffer toolbar, and the hardware interfaces connected to the nRF Sniffer.</p> <p>Tip</p> <p>If the nRF Sniffer toolbar is not visible, select View &gt; Interface Toolbars &gt; nRF Sniffer for Bluetooth LE.</p> <p></p> <p>The following options are available from the capture screen in Wireshark:</p> <code>RSSI filter</code> <p>You can apply a RSSI filter on the packets that are being received. Only packets that match the filter are displayed.</p> <p>You must set the capture filter in the capture screen by using the keyword <code>rssi</code>. For example, the filter <code>rssi &gt;= -70</code> only captures packets that have an RSSI greater than or equal to <code>-70 dBm</code>.</p> <p></p> <code>Interface options</code> <p>Click  next to the interface to configure additional options for the nRF Sniffer for Bluetooth LE.</p> <p></p> <p>The following options are available:</p> <code>Only advertising packets</code> <p>Sniff only the advertising packets of the given device. When a new connection is established, the nRF Sniffer ignores it.</p> <code>Only legacy advertising packets</code> <p>Sniff only the legacy advertising packets of the given device. The nRF Sniffer does not look for the advertiser's device address in extended advertising packets in the auxiliary advertising packets.</p> <code>Find scan response data</code> <p>Follow scan requests and scan responses when sniffing all advertising devices. This option is useful for finding the advertiser's name in the scan response data. You need an active scanner to generate the scan requests to follow.</p> <code>Find auxiliary pointer data</code> <p>Follow the auxiliary pointer for additional data when sniffing all advertising devices. This option is useful for finding the advertiser's address and name in the auxiliary advertising data.</p> <code>Scan and follow devices on LE Coded PHY</code> <p>Sniff on the LE Coded PHY when sniffing all advertising devices and a specific device. The nRF Sniffer follows the connection on any PHY it uses. To sniff on both LE 1M PHY and LE Coded PHY at the same time, use multiple sniffers.</p>"},{"location":"guides/ble-sniffer/usage/","title":"nRF Sniffer usage","text":"<p>Once the nRF Sniffer for Bluetooth LE is running, it reports advertisements and lists nearby devices in the Device List. The software interface has several commands for controlling the operating mode of the nRF Sniffer.</p> <p></p>"},{"location":"guides/ble-sniffer/usage/#basic-operating","title":"Basic operating","text":"<p>The nRF Sniffer has two modes of operation:</p> <ol> <li> <p>Listen on all advertising channels to pick up as many packets as possible from as many devices as possible. This is the default mode.</p> </li> <li> <p>Follow one particular device and try to catch all packets sent to or from this particular device. This mode catches all:</p> <ul> <li>Advertisements and Scan Responses sent from the device</li> <li>Scan Requests and Connect Requests sent to the device</li> <li>Packets in the connection sent between the two devices in the connection</li> </ul> </li> </ol> <code>Hardware interface</code> <p>This list shows the available hardware interfaces. If you have more than one board with the nRF Sniffer firmware connected, you can choose which one to control with the toolbar. To use several hardware interfaces at the same time, see Capturing from multiple hardware interfaces.</p> <code>Device list</code> <p>This list shows nearby devices that are advertising. When you start sniffing, All advertising devices is selected. Choose a device from the list to sniff that specific device. When you select a different device while in a connection, the current connection is no longer sniffed. </p> <p>If the device that you want to sniff is not found by the sniffer, you can add it to the list manually. See <code>Add LE Address</code> below.</p> <p>A device can also be selected from the list by providing the LE address manually. See <code>Follow LE Address</code> below.</p> <p>If the device is privacy-enabled and the LE address is unknown, you can select Follow IRK and enter the IRK. See <code>IRK</code> below.</p> <code>Input key and value</code> <p>Use this field to provide the nRF Sniffer with input information that cannot be captured from air-traffic alone. To do so, select the input key from the drop-down menu and enter the corresponding value in the input field. </p> <p>The following input keys are available:</p> <code>Legacy Passkey</code> <p>If your device asks you to provide your passkey, type the 6-digit passkey in the passkey text field and press Enter. Then enter the passkey into the device.</p> <code>Legacy OOB data</code> <p>If your device uses a legacy pairing procedure with a 16-byte Out of Band (OOB) key, provide it in hexadecimal format (starting with <code>0x</code>, big endian). You must do this before the device enters encryption. If the entered key is shorter than 16 bytes, it is padded with zeros in front.</p> <code>Legacy LTK</code> <p>If your device has an existing bond using a legacy Long Term Key (LTK), provide it in hexadecimal format (starting with <code>0x</code>, big endian). You must do this before the device enters encryption. If the entered key is shorter than 16 bytes, it is padded with zeros in front.</p> <code>SC LTK</code> <p>If your device has an existing bond using an LE Secure Connections LTK, provide it in hexadecimal format (starting with <code>0x</code>, big endian). You must do this before the device enters encryption. If the entered key is shorter than 16 bytes, it is padded with zeros in front.</p> <code>SC Private Key</code> <p>If your device uses LE Secure Connections pairing and neither of the devices is in debug mode (using the Debug private key), provide the 32-byte Diffie-Hellman private key of your device in hexadecimal format (starting with <code>0x</code>, big endian). You must do this before the device starts the pairing procedure. If the entered key is shorter than 32 bytes, it is padded with zeros in front.</p> <code>IRK</code> <p>If your device is privacy-enabled, the IRK is needed to continue to follow the device when it changes its LE address. You should provide it in hexadecimal format (starting with <code>0x</code>, big endian). You must do this before the device enters encryption. If the entered key is shorter than 16 bytes, it is padded with zeros in front. When selecting a device that can be resolved with the IRK, the sniffer continues to follow any LE addresses that also resolves with the IRK. If the current LE address of the device is unknown, the device can be followed by selecting Follow IRK in the device list.</p> <code>Add LE Address</code> <p>If the device that you want to sniff is not currently advertising and therefore was not discovered, use this field to add its LE address to the device list. Input the full 6-byte LE address, separating each byte with a colon, and append the address type (\"public\" or \"random\"). For example: <code>57:25:b0:81:eb:e5 random</code></p> <p>Note</p> <p>If you add a device while capturing is stopped, the device does not show up in the device list until you start capturing.</p> <code>Follow LE Address</code> <p>If the device list is long, use this field to select the LE address in the device list. Input the full 6-byte LE address, separating each byte with a colon, and append the address type (\"public\" or \"random\"). For example: <code>57:25:b0:81:eb:e5 random</code></p> <p>Note</p> <p>If you follow a device while capturing is stopped, the device is not selected until you start capturing.</p> <code>Advertising hop sequence</code> <p>You can change the order in which the nRF Sniffer switches advertising channels when following a device. Define the order with comma-separated channel numbers, for example, <code>37,38,39</code>. Press Enter when done.</p> <p>With the default configuration, the nRF Sniffer waits for a packet on channel 37. After it receives a packet on channel 37, it transitions to sniffing on channel 38. When it receives a packet on channel 38, it transitions to sniffing on channel 39. When it receives a packet on channel 39, it starts sniffing on channel 37, and repeats the operation.</p> <code>Clear button</code> <p>Click this button to remove all entries in the device list and start scanning for new devices. This button is active only when capturing is ongoing.</p> <code>Defaults button</code> <p>Click this button to remove all entries in the device list and set all configuration options to their default values. This button is active only when no capturing is ongoing.</p> <code>Help button</code> <p>Click this button to open the documentation.</p> <code>Log button</code> <p>Click this button to display the debug log and information about the nRF Sniffer version. Check this log if you encounter any issues, and include the information when reporting issues.</p>"},{"location":"guides/ble-sniffer/usage/#capturing-from-multiple-hardware-interfaces","title":"Capturing from multiple hardware interfaces","text":"<p>You can capture packets from several hardware interfaces/devices simultaneously.</p> <p>To capture from multiple hardware interfaces simultaneously, select the hardware interfaces in the capture screen and click Start capturing packets.</p> <p></p> <p>The captured data contains the interface identifier used by Wireshark to identify the capture interface (<code>frame.interface_id</code>) and the hardware identifier for the board running the nRF Sniffer firmware (<code>nordic_ble.board_id</code>).</p> <p></p> <p>Tip</p> <p>If the Board and Interface id columns are not displayed, right-click the table header and select Column Preferences to add them.</p>"},{"location":"guides/ble-sniffer/usage/#inspecting-captured-data","title":"Inspecting captured data","text":"<p>All Bluetooth\u00ae Low Energy packets detected by the Sniffer for Bluetooth LE are passed to Wireshark, where they are wrapped in a header containing useful meta-information not present in the Bluetooth Low Energy packet itself. Wireshark dissects the packets and separates the actual packet from the meta-information.</p> <p>When you browse captured packets, select a packet in the packet list to show the breakdown of that packet in the packet Details pane. The bytes of the packet are shown in the packet bytes pane. Click a value in the details to highlight it among the bytes, or click on the bytes to highlight it in the details.</p> <p></p> <p>To view the display filter for any field, click a value in the packet details pane. The display filter is shown in the bottom left corner.</p> <p></p> <p>Use display filters to display a chosen packet subset. Most filters are based on the values of the packets, such as length or access address. The filter expressions use Boolean operators (<code>&amp;&amp;</code> <code>||</code> <code>==</code> <code>!=</code> <code>!</code>). To construct a filter, click Expression in the filtering bar. See the following table for some examples.</p> Display filter Description <code>btle.length != 0</code> Filter that displays only packets where the length field of the Bluetooth Low Energy packet is not zero, meaning it hides empty data packets. <code>btle.advertising_address</code> Filter that displays only packets that have an advertising address (advertising packets). <code>btle</code> Protocol filter that displays all Bluetooth Low Energy packets. <code>btatt, btsmp, btl2cap</code> Protocol filters for ATT, SMP, and L2CAP packets, respectively. <code>nordic_ble.channel &lt; 37</code> Filter that displays only packets received on the data channels. <p>The following tips can help when inspecting your data:</p> <ul> <li> <p>Turn any field in the packet details pane into a column. To do so:</p> <ol> <li>Right-click the value in the packet details.</li> <li>Click Apply as Column.</li> </ol> <p></p> </li> <li> <p>Apply a value as a filter to, for example, see only operations affecting a particular handle. To filter packets that have a specific value for some field:</p> <ol> <li>Right-click the value in the packet details.</li> <li>Click Apply as Filter.</li> <li>Click Selected.</li> </ol> </li> <li> <p>Save a set of captured packets to be able to look at them later. To do so:</p> <ol> <li>Click the Stop button to stop capturing packets.</li> <li>Click File &gt; Save As to save all packets, or click File &gt; Export Specified Packets to save a selection of packets.</li> </ol> </li> <li> <p>Clear the packet list and restart a capture by clicking the Restart button</p> </li> </ul>"},{"location":"guides/ncs/","title":"nRF Connect SDK","text":""},{"location":"guides/ncs/#introduction","title":"Introduction","text":"<p>The nRF Connect SDK is a scalable and unified software development kit for building low-power wireless applications based on the Nordic Semiconductor nRF52, nRF53, and nRF91 Series wireless devices. It offers an extensible framework for building size-optimized software for memory-constrained devices as well as powerful and complex software for more advanced devices and applications.</p> <p>It integrates the Zephyr\u2122 real-time operating system (RTOS), a wide range of complete applications, samples, and protocol stacks such as Bluetooth\u00ae Low Energy, Bluetooth mesh, Matter, Thread/Zigbee and LTE-M/NB-IoT/GPS, TCP/IP. It also includes middleware such as CoAP, MQTT, LwM2M, various libraries, hardware drivers, Trusted Firmware-M for security, and a secure bootloader (MCUboot).</p>"},{"location":"guides/ncs/#get-involved","title":"Get Involved","text":"<p>We think the best way to learn is by doing. The following sections take you through the basics of nRF Connect SDK development and show you how to implement typical use cases with Nordic Semiconductor libraries and drivers on nRF52840 Connect Kit.</p> <ul> <li>Setting up the environment</li> <li>Building and running the first sample</li> <li>Samples<ul> <li>Hello World</li> <li>Blinky</li> <li>Button</li> <li>Voltage Measurement</li> <li>QSPI NOR Flash</li> <li>USB HID Mouse</li> <li>USB Mass Storage</li> <li>NFC Launch App</li> <li>NFC Text record</li> <li>NFC URI record</li> <li>NFC Writable NDEF message</li> <li>BLE Beacon</li> <li>BLE Observer</li> <li>BLE Peripheral</li> <li>BLE Peripheral LBS</li> <li>BLE Peripheral HIDS keyboard</li> <li>BLE Peripheral HIDS mouse</li> <li>BLE NUS shell transport</li> <li>Thread CLI</li> <li>Thread CoAP</li> <li>Thread Co-processor</li> <li>Zigbee Lighting</li> <li>Zigbee NCP</li> <li>Zigbee Shell</li> </ul> </li> </ul>"},{"location":"guides/ncs/#reference","title":"Reference","text":"<ul> <li>nRF Connect SDK Documentation</li> <li>Zephyr Project Documentation</li> </ul>"},{"location":"guides/ncs/building/","title":"Building and running the first sample","text":"<p>This guide explains how to build and run the first sample (for example, Blinky).</p> <p>Before you start building, remember to set up the environment first.</p>"},{"location":"guides/ncs/building/#build-the-blinky-sample","title":"Build the Blinky sample","text":"<p>After completing the environment setup, use the following steps to build the Blinky sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/blinky\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/ncs/building/#flash-and-run-the-sample","title":"Flash and run the sample","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the Green LED will start to blink.</p> <p></p> </li> </ol>"},{"location":"guides/ncs/building/#next-steps","title":"Next steps","text":"<p>Try more samples on nRF52840 Connect Kit:</p> <ul> <li>Hello World</li> <li>Blinky</li> <li>Button</li> <li>Voltage Measurement</li> <li>QSPI NOR Flash</li> <li>USB HID Mouse</li> <li>USB Mass Storage</li> <li>NFC Launch App</li> <li>NFC Text record</li> <li>NFC URI record</li> <li>NFC Writable NDEF message</li> <li>BLE Beacon</li> <li>BLE Observer</li> <li>BLE Peripheral</li> <li>BLE Peripheral LBS</li> <li>BLE Peripheral HIDS keyboard</li> <li>BLE Peripheral HIDS mouse</li> <li>BLE NUS shell transport</li> <li>Thread CLI</li> <li>Thread CoAP</li> <li>Thread Co-processor</li> <li>Zigbee Lighting</li> <li>Zigbee NCP</li> <li>Zigbee Shell</li> </ul> <p>nRF Connect SDK and Zephyr also provide a variety of application samples and demos. Documentation for those is available in:</p> <ul> <li>Zephyr's Samples and Demos</li> <li>nRF Connect SDK's Samples</li> <li>nRF Connect SDK's Applications</li> </ul>"},{"location":"guides/ncs/setup/","title":"Setting up the environment","text":"<p>To start working with the nRF Connect SDK, you should set up your development environment. nRF Connect SDK is based on the Zephyr RTOS, which means most of the requirements for Zephyr are also suitable for the nRF Connect SDK. The only requirement that is not covered by the installation steps in Zephyr is the GN tool. This tool is needed only for Matter applications.</p> <p>This guide shows you how to set up a command-line nRF Connect SDK development environment on Ubuntu, macOS, or Windows manually. For automatic installation, please refer to the Installing automatically page.</p>"},{"location":"guides/ncs/setup/#select-and-update-os","title":"Select and Update OS","text":"<p>Install available updates for your operating system:</p> WindowsmacOSUbuntu <p>Select Start &gt; Settings &gt; Update &amp; Security &gt; Windows Update. Click Check for updates and install any that are available.</p> <p>On macOS Mojave or later, select System Preferences... &gt; Software Update. Click Update Now if necessary.</p> <p>On other versions, see this Apple support topic.</p> <p>This guide covers Ubuntu version 18.04 LTS and later.</p> <pre><code>sudo apt update\n</code></pre> <pre><code>sudo apt upgrade\n</code></pre>"},{"location":"guides/ncs/setup/#install-dependencies","title":"Install dependencies","text":"<p>Next, you\u2019ll install some host dependencies using your package manager.</p> <p>The current minimum required version for the main dependencies are:</p> Tool Min. Version CMake 3.20.0 Python 3.8 Devicetree compiler 1.4.6 WindowsmacOSUbuntu <p>We use Chocolatey to install dependencies here. If Chocolatey isn\u2019t an option, you can install dependencies from their respective websites and ensure the command line tools added in your <code>PATH</code> environment variable.</p> <ol> <li> <p>Install chocolatey.</p> </li> <li> <p>Open a <code>cmd.exe</code> window as Administrator. To do so, press the Windows key Win , type <code>cmd.exe</code>, right-click the result, and choose Run as Administrator.</p> </li> <li> <p>Disable global confirmation to avoid having to confirm the installation of individual programs:</p> <pre><code>choco feature enable -n allowGlobalConfirmation\n</code></pre> </li> <li> <p>Use <code>choco</code> to install the required dependencies:</p> <pre><code>choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System'\n</code></pre> <pre><code>choco install ninja gperf python git dtc-msys2 wget unzip\n</code></pre> </li> <li> <p>Close the window and open a new <code>cmd.exe</code> window as a regular user to continue.</p> </li> </ol> <p>Tip</p> <p>To check the list of installed packages and their versions, run the following command:</p> <pre><code>choco list -lo\n</code></pre> <ol> <li> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> </li> <li> <p>Use <code>brew</code> to install the required dependencies:</p> <pre><code>brew install cmake ninja gperf python3 ccache qemu dtc wget libmagic\n</code></pre> </li> </ol> <p>Tip</p> <p>To check the versions of these dependencies installed, run the following command:</p> <pre><code>brew list --versions\n</code></pre> <ol> <li> <p>If using an Ubuntu version older than 22.04, it is necessary to add extra repositories to meet the minimum required versions for the main dependencies listed above. In that case, download, inspect and execute the Kitware archive script to add the Kitware APT repository to your sources list. A detailed explanation of <code>kitware-archive.sh</code> can be found here kitware third-party apt repository:</p> <pre><code>wget https://apt.kitware.com/kitware-archive.sh\n</code></pre> <pre><code>sudo bash kitware-archive.sh\n</code></pre> </li> <li> <p>Use <code>apt</code> to install the required dependencies:</p> <pre><code>sudo apt install --no-install-recommends git cmake ninja-build gperf \\\nccache dfu-util device-tree-compiler wget \\\npython3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\\nmake gcc gcc-multilib g++-multilib libsdl2-dev libmagic1\n</code></pre> </li> <li> <p>Verify the versions of the main dependencies installed on your system by entering:</p> <pre><code>cmake --version\n</code></pre> <pre><code>python3 --version\n</code></pre> <pre><code>dtc --version\n</code></pre> </li> </ol> Install GN tool for Matter <p>If you want to build Matter applications, additionally install the GN meta-build system. This system generates the Ninja files that the nRF Connect SDK uses.</p> WindowsmacOSLinux <p>To install the GN tool, complete the following steps:</p> <ol> <li> <p>Download the latest version of the GN binary archive for Windows from the GN website.</p> </li> <li> <p>Extract the <code>zip</code> archive.</p> </li> <li> <p>Ensure that the GN tool is added to your <code>PATH</code> environment variable.</p> </li> </ol> <p>To install the GN tool, complete the following steps:</p> <ol> <li> <p>Create the directory for the GN tool:</p> <pre><code>mkdir ${HOME}/gn &amp;&amp; cd ${HOME}/gn\n</code></pre> </li> <li> <p>Download the GN binary archive and extract it by using the following commands:</p> Apple Silicon (M1 &amp; M2)64-bit AMD (Intel) <pre><code>wget -O gn.zip https://chrome-infra-packages.appspot.com/dl/gn/gn/mac-arm64/+/latest\n</code></pre> <pre><code>unzip gn.zip\n</code></pre> <pre><code>rm gn.zip\n</code></pre> <pre><code>wget -O gn.zip https://chrome-infra-packages.appspot.com/dl/gn/gn/mac-amd64/+/latest\n</code></pre> <pre><code>unzip gn.zip\n</code></pre> <pre><code>rm gn.zip\n</code></pre> </li> <li> <p>Add the location of the GN tool to the system <code>PATH</code>. For example, if you are using <code>bash</code>, run the following commands:</p> <ol> <li> <p>Create the <code>.bash_profile</code> file if you do not have it already:</p> <pre><code>touch ${HOME}/.bash_profile\n</code></pre> </li> <li> <p>Add the location of the GN tool to <code>.bash_profile</code>:</p> <pre><code>echo 'export PATH=${HOME}/gn:\"$PATH\"' &gt;&gt; ${HOME}/.bash_profile\n</code></pre> <pre><code>source ${HOME}/.bash_profile\n</code></pre> </li> </ol> </li> </ol> <p>To install the GN tool, complete the following steps:</p> <ol> <li> <p>Create the directory for the GN tool:</p> <pre><code>mkdir ${HOME}/gn &amp;&amp; cd ${HOME}/gn\n</code></pre> </li> <li> <p>Download the GN binary archive and extract it by using the following commands:</p> <pre><code>wget -O gn.zip https://chrome-infra-packages.appspot.com/dl/gn/gn/linux-amd64/+/latest\n</code></pre> <pre><code>unzip gn.zip\n</code></pre> <pre><code>rm gn.zip\n</code></pre> </li> <li> <p>Add the location of the GN tool to the system <code>PATH</code>. For example, if you are using <code>bash</code>, run the following commands:</p> <pre><code>echo 'export PATH=${HOME}/gn:\"$PATH\"' &gt;&gt; ${HOME}/.bashrc\n</code></pre> <pre><code>source ${HOME}/.bashrc\n</code></pre> </li> </ol>"},{"location":"guides/ncs/setup/#install-west","title":"Install west","text":"<p>To manage the combination of repositories and versions, the nRF Connect SDK uses Zephyr\u2019s west.</p> <p>To install west, reopen the command prompt window as an administrator to ensure that Python is initialized, and complete the following step:</p> WindowsmacOSUbuntu <p>Enter the following command in a command-line window:</p> <pre><code>pip3 install west\n</code></pre> <p>Note</p> <p>Ensure the west location is added to the path in environmental variables.</p> <p>Enter the following command in a terminal window:</p> <pre><code>pip3 install west\n</code></pre> <p>Enter the following command in a terminal window:</p> <pre><code>pip3 install --user west\n</code></pre> <pre><code>echo 'export PATH=~/.local/bin:\"$PATH\"' &gt;&gt; ~/.bashrc\n</code></pre> <pre><code>source ~/.bashrc\n</code></pre>"},{"location":"guides/ncs/setup/#get-the-code","title":"Get the code","text":"<p>To help you quickly build and run the samples on nRF52840 Connect Kit, we maintain a public repository named ncs-playground which consists of nRF Connect SDK manifest repositories, additional hardware drivers and tested samples, etc.</p> <p>To clone the repositories, complete the following steps:</p> <ol> <li> <p>Initialize the workspace folder (<code>my-workspace</code>) where all the required repositories will be cloned:</p> <pre><code>west init -m https://github.com/makerdiary/ncs-playground --mr main my-workspace\n</code></pre> <p>Tip</p> <p>You can initialize west with the revision of ncs-playground that you want to check out. For example, to check out the <code>v0.1.0-rc1</code> release, enter the following command:</p> <pre><code>west init -m https://github.com/makerdiary/ncs-playground --mr v0.1.0-rc1 my-workspace\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd my-workspace\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>my-workspace\n|___ .west\n|___ bootloader\n|___ ncs-playground\n|___ modules\n|___ nrf\n|___ nrfxlib\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load the boilerplate code required for building nRF Connect SDK applications:</p> <pre><code>west zephyr-export\n</code></pre> </li> </ol>"},{"location":"guides/ncs/setup/#install-additional-python-dependencies","title":"Install additional Python dependencies","text":"<p>The nRF Connect SDK requires additional Python packages to be installed. Use the following commands to install the requirements for each repository.</p> WindowsmacOSUbuntu <p>Enter the following command in a command-line window in the <code>my-workspace</code> folder:</p> <pre><code>pip3 install -r zephyr/scripts/requirements.txt\n</code></pre> <pre><code>pip3 install -r nrf/scripts/requirements.txt\n</code></pre> <pre><code>pip3 install -r bootloader/mcuboot/scripts/requirements.txt\n</code></pre> <p>Enter the following command in a terminal in the <code>my-workspace</code> folder:</p> <pre><code>pip3 install -r zephyr/scripts/requirements.txt\n</code></pre> <pre><code>pip3 install -r nrf/scripts/requirements.txt\n</code></pre> <pre><code>pip3 install -r bootloader/mcuboot/scripts/requirements.txt\n</code></pre> <p>Enter the following command in a terminal in the <code>my-workspace</code> folder:</p> <pre><code>pip3 install --user -r zephyr/scripts/requirements.txt\n</code></pre> <pre><code>pip3 install --user -r nrf/scripts/requirements.txt\n</code></pre> <pre><code>pip3 install --user -r bootloader/mcuboot/scripts/requirements.txt\n</code></pre>"},{"location":"guides/ncs/setup/#install-zephyr-sdk","title":"Install Zephyr SDK","text":"<p>The Zephyr Software Development Kit (SDK) contains toolchains for each of Zephyr\u2019s supported architectures, which include a compiler, assembler, linker and other programs required to build Zephyr applications.</p> <p>It also contains additional host tools, such as custom QEMU and OpenOCD builds that are used to emulate, flash and debug Zephyr applications.</p> WindowsmacOSUbuntu <ol> <li>Open a <code>cmd.exe</code> window by pressing the Windows key typing <code>cmd.exe</code>.</li> <li> <p>Download the latest Zephyr SDK bundle:</p> <pre><code>cd %HOMEPATH%\n</code></pre> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.2/zephyr-sdk-0.15.2_windows-x86_64.zip\n</code></pre> </li> <li> <p>Extract the Zephyr SDK bundle archive:</p> <pre><code>unzip zephyr-sdk-0.15.2_windows-x86_64.zip\n</code></pre> <p>Note</p> <p>It is recommended to extract the Zephyr SDK bundle at one of the following locations:</p> <ul> <li><code>%HOMEPATH%</code></li> <li><code>%PROGRAMFILES%</code></li> </ul> <p>The Zephyr SDK bundle archive contains the <code>zephyr-sdk-0.15.2</code> directory and, when extracted under <code>%HOMEPATH%</code>, the resulting installation path will be <code>%HOMEPATH%\\zephyr-sdk-0.15.2</code>.</p> </li> <li> <p>Run the Zephyr SDK bundle setup script:</p> <pre><code>cd zephyr-sdk-0.15.2\n</code></pre> <pre><code>setup.cmd\n</code></pre> <p>Note</p> <p>You only need to run the setup script once after extracting the Zephyr SDK bundle.</p> <p>You must rerun the setup script if you relocate the Zephyr SDK bundle directory after the initial setup.</p> </li> </ol> <ol> <li> <p>Download and verify the latest Zephyr SDK bundle:</p> <pre><code>cd ~\n</code></pre> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.2/zephyr-sdk-0.15.2_macos-x86_64.tar.gz\n</code></pre> <pre><code>wget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.2/sha256.sum | shasum --check --ignore-missing\n</code></pre> <p>If your host architecture is 64-bit ARM (Apple Silicon, also known as M1), replace <code>x86_64</code> with <code>aarch64</code> in order to download the 64-bit ARM macOS SDK.</p> </li> <li> <p>Extract the Zephyr SDK bundle archive:</p> <pre><code>tar xvf zephyr-sdk-0.15.2_macos-x86_64.tar.gz\n</code></pre> <p>Note</p> <p>It is recommended to extract the Zephyr SDK bundle at one of the following locations:</p> <ul> <li><code>$HOME</code></li> <li><code>$HOME/.local</code></li> <li><code>$HOME/.local/opt</code></li> <li><code>$HOME/bin</code></li> <li><code>/opt</code></li> <li><code>/usr/local</code></li> </ul> <p>The Zephyr SDK bundle archive contains the <code>zephyr-sdk-0.15.2</code> directory and, when extracted under <code>$HOME</code>, the resulting installation path will be <code>$HOME/zephyr-sdk-0.15.2</code>.</p> </li> <li> <p>Run the Zephyr SDK bundle setup script:</p> <pre><code>cd zephyr-sdk-0.15.2\n</code></pre> <pre><code>./setup.sh\n</code></pre> <p>Note</p> <p>You only need to run the setup script once after extracting the Zephyr SDK bundle.</p> <p>You must rerun the setup script if you relocate the Zephyr SDK bundle directory after the initial setup.</p> </li> </ol> <ol> <li> <p>Download and verify the latest Zephyr SDK bundle:</p> <pre><code>cd ~\n</code></pre> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.2/zephyr-sdk-0.15.2_linux-x86_64.tar.gz\n</code></pre> <pre><code>wget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.15.2/sha256.sum | shasum --check --ignore-missing\n</code></pre> <p>If your host architecture is 64-bit ARM (for example, Raspberry Pi), replace <code>x86_64</code> with <code>aarch64</code> in order to download the 64-bit ARM Linux SDK.</p> </li> <li> <p>Extract the Zephyr SDK bundle archive:</p> <pre><code>tar xvf zephyr-sdk-0.15.2_linux-x86_64.tar.gz\n</code></pre> <p>Note</p> <p>It is recommended to extract the Zephyr SDK bundle at one of the following locations:</p> <ul> <li><code>$HOME</code></li> <li><code>$HOME/.local</code></li> <li><code>$HOME/.local/opt</code></li> <li><code>$HOME/bin</code></li> <li><code>/opt</code></li> <li><code>/usr/local</code></li> </ul> <p>The Zephyr SDK bundle archive contains the <code>zephyr-sdk-0.15.2</code> directory and, when extracted under <code>$HOME</code>, the resulting installation path will be <code>$HOME/zephyr-sdk-0.15.2</code>.</p> </li> <li> <p>Run the Zephyr SDK bundle setup script:</p> <pre><code>cd zephyr-sdk-0.15.2\n</code></pre> <pre><code>./setup.sh\n</code></pre> <p>Note</p> <p>You only need to run the setup script once after extracting the Zephyr SDK bundle.</p> <p>You must rerun the setup script if you relocate the Zephyr SDK bundle directory after the initial setup.</p> </li> <li> <p>Install udev rules, which allow you to flash most Zephyr boards as a regular user:</p> <pre><code>sudo cp ~/zephyr-sdk-0.15.2/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d\n</code></pre> <pre><code>sudo udevadm control --reload\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/blinky/","title":"Blinky","text":""},{"location":"guides/ncs/samples/blinky/#overview","title":"Overview","text":"<p>The Blinky sample blinks an LED forever using the GPIO API.</p> <p>The source code shows how to:</p> <ol> <li> <p>Get a pin specification from the devicetree as a <code>gpio_dt_spec</code></p> </li> <li> <p>Configure the GPIO pin as an output</p> </li> <li> <p>Toggle the pin forever</p> </li> </ol>"},{"location":"guides/ncs/samples/blinky/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/blinky/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Blinky sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/blinky\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/ncs/samples/blinky/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/blinky/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, the Green LED starts to blink.</p> <p></p>"},{"location":"guides/ncs/samples/button/","title":"Button","text":""},{"location":"guides/ncs/samples/button/#overview","title":"Overview","text":"<p>A simple button sample demonstrates the use of GPIO input with interrupts. The sample prints a message to the console each time a button is pressed.</p>"},{"location":"guides/ncs/samples/button/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/button/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Button sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/button\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/ncs/samples/button/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/button/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal and press the USER button. You should see the output, similar to what is shown in the following:</p> <pre><code>Set up button at GPIO_1 pin 0\nSet up LED at GPIO_1 pin 15\nPress the button\nButton pressed at 281102\nButton pressed at 310379\nButton pressed at 341776\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/hello_world/","title":"Hello World","text":""},{"location":"guides/ncs/samples/hello_world/#overview","title":"Overview","text":"<p>The Hello World sample can be used as a start point of nRF Connect SDK application development. This sample is quite simple and just prints <code>Hello World</code> to the console over USB serial console.</p>"},{"location":"guides/ncs/samples/hello_world/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/hello_world/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Hello World sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/hello_world\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/ncs/samples/hello_world/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/hello_world/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>Hello World! connectkit_nrf52840\nHello World! connectkit_nrf52840\nHello World! connectkit_nrf52840\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/qspi_flash/","title":"QSPI NOR Flash","text":""},{"location":"guides/ncs/samples/qspi_flash/#overview","title":"Overview","text":"<p>The QSPI NOR Flash sample demonstrates using the flash API on a QSPI NOR serial flash memory device. While trivial it is an example of direct access and allows confirmation that the flash is working and that automatic power savings is correctly implemented.</p> <p>The QSPI NOR flash is connected to the nRF52840 chip over a QSPI bus. The table below shows the connections of each pin of QSPI flash:</p> QSPI Flash Pin nRF52840 Pin <code>CS#</code> <code>P0.17</code> <code>SCLK</code> <code>P0.19</code> <code>SIO0</code> <code>P0.20</code> <code>SIO1</code> <code>P0.21</code> <code>SIO2</code> <code>P0.22</code> <code>SIO3</code> <code>P0.23</code>"},{"location":"guides/ncs/samples/qspi_flash/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/qspi_flash/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the QSPI NOR Flash sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/qspi_flash\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/qspi_flash/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/qspi_flash/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>mx25r6435f@0 QSPI flash testing\n==========================\nTest 1: Flash erase\nFlash erase succeeded!\n\nTest 2: Flash write\nAttempting to write 4 bytes\nData read matches data written. Good!!\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/voltage_measurement/","title":"Voltage Measurement","text":""},{"location":"guides/ncs/samples/voltage_measurement/#overview","title":"Overview","text":"<p>The Voltage Measurement sample demonstrates using Nordic configurations of the Zephyr ADC infrastructure to measure the voltage of the device power supply.</p> <p>The measurement circuit contains a voltage divider made of two resistors. AIN0 measures the voltage over the lower resistor and P1.14 is used to enable the voltage measurement. The voltage measurement circuitry is shown in the following figure:</p> <p></p> <p>The board devicetree has a <code>power_vsys_in</code> node with compatible <code>voltage-divider</code>. The voltage is measured using that divider. The devicetree node describing is shown below:</p> <pre><code>power_vsys_in {\ncompatible = \"voltage-divider\";\nio-channels = &lt;&amp;adc 0&gt;;\noutput-ohms = &lt;100000&gt;;\nfull-ohms = &lt;(1000000 + 100000)&gt;;\npower-gpios = &lt;&amp;gpio1 14 0&gt;;\n};\n</code></pre>"},{"location":"guides/ncs/samples/voltage_measurement/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/voltage_measurement/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Voltage Measurement sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/voltage_measurement\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>. </p> </li> </ol>"},{"location":"guides/ncs/samples/voltage_measurement/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/voltage_measurement/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> <pre><code>ADC reading:\n- adc@40007000, channel 0: 771 = 451 mV, VSYS = 4961 mV\nADC reading:\n- adc@40007000, channel 0: 771 = 451 mV, VSYS = 4961 mV\nADC reading:\n- adc@40007000, channel 0: 769 = 450 mV, VSYS = 4950 mV\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/ble/beacon/","title":"Bluetooth Low Energy: Beacon","text":""},{"location":"guides/ncs/samples/ble/beacon/#overview","title":"Overview","text":"<p>The BLE Beacon sample demonstrates the BLE Broadcaster role functionality by advertising an Eddystone URL \"https://makerdiary.com\".</p> <p>The following Eddystone specifications describe the Advertisement data:</p> <ul> <li>Eddystone Protocol Specification</li> <li>Eddystone-URL</li> </ul>"},{"location":"guides/ncs/samples/ble/beacon/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with nRF Connect for Mobile installed</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/ble/beacon/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the BLE Beacon sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/beacon\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/beacon/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/beacon/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li> <p>Power up nRF52840 Connect Kit by using the USB-C Cable.</p> </li> <li> <p>Start the nRF Connect for Mobile app, scan the device and observe that the beacon is advertising an Eddystone URL (https://makerdiary.com) with the Device Name <code>Test beacon</code>.</p> </li> </ol> <p></p>"},{"location":"guides/ncs/samples/ble/observer/","title":"Bluetooth Low Energy: Observer","text":""},{"location":"guides/ncs/samples/ble/observer/#overview","title":"Overview","text":"<p>The BLE Observer sample demonstrates Bluetooth Low Energy Observer role functionality. The application will periodically scan for devices nearby. If any found, prints the address of the device, the RSSI value, the Advertising type, and the Advertising data length to the console.</p> <p>If the used Bluetooth Low Energy Controller supports Extended Scanning, you may enable <code>CONFIG_BT_EXT_ADV</code> in the project configuration file. Refer to the project configuration file for further details.</p>"},{"location":"guides/ncs/samples/ble/observer/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/ble/observer/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the BLE Observer sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> DefaultExtended Scanning <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/observer\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/observer -- -DCONF_FILE=prj_extended.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/observer/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/observer/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> DefaultExtended Scanning <pre><code>Starting Observer Demo\nStarted scanning...\nDevice found: 49:38:F7:6C:CB:E0 (random) (RSSI -86), type 0, AD data len 31\nDevice found: 50:96:57:16:C0:DF (random) (RSSI -85), type 0, AD data len 29\nDevice found: CC:72:86:07:B4:7F (public) (RSSI -90), type 0, AD data len 19\nDevice found: CC:72:86:08:3F:F1 (public) (RSSI -83), type 0, AD data len 19\nDevice found: 5D:38:F1:C7:C5:BB (random) (RSSI -90), type 0, AD data len 31\n...\n</code></pre> <pre><code>Starting Observer Demo\nStarted scanning...\nDevice found: CC:72:86:08:3F:F1 (public) (RSSI -82), type 0, AD data len 19\n[DEVICE]: CC:72:86:08:3F:F1 (public), AD evt type 0, Tx Pwr: 127, RSSI -82 Data status: 0, AD data len: 19 Name:  C:1 S:1 D:0 SR:0 E:0 Pri PHY: LE 1M, Sec PHY: No packets, Interval: 0x0000 (0 ms), SID: 255\nDevice found: 76:B5:1F:C0:CF:0D (random) (RSSI -84), type 0, AD data len 26\n[DEVICE]: 76:B5:1F:C0:CF:0D (random), AD evt type 0, Tx Pwr: 127, RSSI -84 Data status: 0, AD data len: 26 Name:  C:1 S:1 D:0 SR:0 E:0 Pri PHY: LE 1M, Sec PHY: No packets, Interval: 0x0000 (0 ms), SID: 255\nDevice found: CC:72:86:1D:4F:31 (public) (RSSI -71), type 0, AD data len 19\n[DEVICE]: CC:72:86:1D:4F:31 (public), AD evt type 0, Tx Pwr: 127, RSSI -71 Data status: 0, AD data len: 19 Name:  C:1 S:1 D:0 SR:0 E:0 Pri PHY: LE 1M, Sec PHY: No packets, Interval: 0x0000 (0 ms), SID: 255\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral/","title":"Bluetooth Low Energy: Peripheral","text":""},{"location":"guides/ncs/samples/ble/peripheral/#overview","title":"Overview","text":"<p>The BLE Peripheral sample demonstrates the BLE Peripheral role. It has several well-known and vendor-specific GATT services that it exposes.</p>"},{"location":"guides/ncs/samples/ble/peripheral/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with nRF Connect for Mobile installed</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/ble/peripheral/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the BLE Peripheral sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/peripheral\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>Start the nRF Connect for Mobile app, scan the device and observe that the device is advertising with the Device Name <code>Zephyr Peripheral Sample Long Name</code>.</li> <li> <p>Connect to the device from the nRF Connect for Mobile app. The services of the connected device are shown in the Client tab.</p> <p> </p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_hids_keyboard/","title":"Bluetooth Low Energy: Peripheral HIDS keyboard","text":""},{"location":"guides/ncs/samples/ble/peripheral_hids_keyboard/#overview","title":"Overview","text":"<p>The BLE Peripheral HIDS keyboard sample demonstrates how to use the GATT Human Interface Device (HID) Service to implement a keyboard input device that you can connect to your computer.</p>"},{"location":"guides/ncs/samples/ble/peripheral_hids_keyboard/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer, with Bluetooth LE supported</li> </ul>"},{"location":"guides/ncs/samples/ble/peripheral_hids_keyboard/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the BLE Peripheral HIDS keyboard sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/peripheral_hids_keyboard\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_hids_keyboard/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_hids_keyboard/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>On your computer, search for Bluetooth devices and connect to the device named <code>Nordic_HIDS_keyboard</code>.</li> <li>When pairing, press USER button to confirm the passkey value.</li> <li>Open a text editor, repeatedly press USER button on the board. Every button press sends one character of the test message <code>hello</code> (the test message includes a carriage return) to the computer, and this will be displayed in the text editor.</li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_hids_mouse/","title":"Bluetooth Low Energy: Peripheral HIDS mouse","text":""},{"location":"guides/ncs/samples/ble/peripheral_hids_mouse/#overview","title":"Overview","text":"<p>The BLE Peripheral HIDS mouse sample demonstrates how to use the GATT Human Interface Device (HID) Service to implement a mouse input device that you can connect to your computer. This sample also shows how to perform directed advertising.</p>"},{"location":"guides/ncs/samples/ble/peripheral_hids_mouse/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer, with Bluetooth LE supported</li> </ul>"},{"location":"guides/ncs/samples/ble/peripheral_hids_mouse/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the BLE Peripheral HIDS mouse sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/peripheral_hids_mouse\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_hids_mouse/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_hids_mouse/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>On your computer, search for Bluetooth devices and connect to the device named <code>Nordic_HIDS_mouse</code>.</li> <li>When pairing, press USER button to confirm the passkey value.</li> <li>Push USER button on the board. Observe that the mouse pointer on the computer moves to the left.</li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_lbs/","title":"Bluetooth Low Energy: Peripheral LBS","text":""},{"location":"guides/ncs/samples/ble/peripheral_lbs/#overview","title":"Overview","text":"<p>The BLE Peripheral LBS sample demonstrates how to use the LED Button Service (LBS).</p> <p>The GATT LED Button Service (LBS) is a custom service that receives information about the state of an LED and sends notifications when a button changes its state.</p> <p>When connected, the sample sends the state of USER button to the connected device, such as a phone or tablet. The mobile application on the device can display the received button state and control the state of Green LED.</p>"},{"location":"guides/ncs/samples/ble/peripheral_lbs/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with nRF Connect for Mobile installed</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/ble/peripheral_lbs/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the BLE Peripheral LBS sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/peripheral_lbs\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_lbs/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/peripheral_lbs/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>Start the nRF Connect for Mobile app, scan the device and observe that the device is advertising with the Device Name <code>Nordic_LBS</code>.</li> <li> <p>Connect to the device from the application. The LBS Service with UUID <code>00001523-1212-EFDE-1523-785FEABCD123</code> is shown. This service has two characteristics:</p> <ul> <li>Button Characteristic with UUID <code>00001524-1212-EFDE-1523-785FEABCD123</code></li> <li>LED Characteristic with UUID <code>00001525-1212-EFDE-1523-785FEABCD123</code></li> </ul> <p> </p> </li> <li> <p>In the Button Characteristic, click  to enable notifications, press USER button on the board and observe that notifications with the following values are displayed:</p> <ul> <li><code>Button Released</code> when USER button is released.</li> <li><code>Button Pressed</code> when USER button is pressed.</li> </ul> <p></p> </li> <li> <p>In the LED Characteristic, click , then select <code>Bool</code> and switch to <code>True</code> or <code>False</code> to control the Green LED on the board. Then click Write to write the value and observe the state of the Green LED.</p> <p></p> </li> </ol>"},{"location":"guides/ncs/samples/ble/shell_bt_nus/","title":"Bluetooth Low Energy: NUS shell transport","text":""},{"location":"guides/ncs/samples/ble/shell_bt_nus/#overview","title":"Overview","text":"<p>The Nordic UART Service (NUS) shell transport sample demonstrates how to use the Nordic UART Service (NUS) shell transport to receive shell commands from a remote device over Bluetooth\u00ae.</p> <p>When the connection is established, you can connect to the sample through the Nordic UART Service (NUS) by using Web Device CLI. You can then send shell commands that are executed on the device running the sample.</p>"},{"location":"guides/ncs/samples/ble/shell_bt_nus/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>Chrome 56+ browser with Web Bluetooth supported</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/ble/shell_bt_nus/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the NUS shell transport sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/ble/shell_bt_nus\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/shell_bt_nus/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/ble/shell_bt_nus/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit using the USB-C Cable.</li> <li> <p>Open the Web Device CLI page in the Chrome brower:</p> <p> Web Device CLI</p> </li> <li> <p>Click Connect to scan devices.</p> </li> <li>Pair  <code>BT_NUS_shell</code> discovered in the list.</li> <li>Run <code>help</code> to print the help message.</li> </ol> <p></p>"},{"location":"guides/ncs/samples/nfc/launch_app/","title":"NFC Launch App","text":""},{"location":"guides/ncs/samples/nfc/launch_app/#overview","title":"Overview","text":"<p>The NFC Launch App sample shows how to use the NFC tag to launch an app on the polling smartphone. It uses the NFC Data Exchange Format (NDEF) library.</p> <p>When the sample starts, it initializes the NFC tag and generates an NDEF message with two records that contain the app Universal Link and Android Application Record. Then it sets up the NFC library to use the generated message and sense the external NFC field.</p> <p>The only events handled by the application are the NFC events. The Green LED turns on when an NFC field is present.</p>"},{"location":"guides/ncs/samples/nfc/launch_app/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>A 13.56MHz NFC Antenna</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with NFC support</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/nfc/launch_app/#wiring-the-nfc-antenna","title":"Wiring the NFC antenna","text":""},{"location":"guides/ncs/samples/nfc/launch_app/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the NFC Launch App sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/nfc/record_launch_app\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/launch_app/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/launch_app/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>Touch the NFC antenna with the smartphone or tablet and observe that Green LED is lit.</li> <li>Observe that the smartphone or tablet launches the nRF Toolbox application.</li> <li>Move the smartphone or tablet away from the NFC antenna and observe that Green LED turns off.</li> </ol> <p>Note</p> <p>Devices running iOS require the nRF Toolbox app to be installed before testing the sample. Devices running Android open Google Play when the application is not installed.</p>"},{"location":"guides/ncs/samples/nfc/text_record/","title":"NFC Text record","text":""},{"location":"guides/ncs/samples/nfc/text_record/#overview","title":"Overview","text":"<p>The NFC Text record sample shows how to use the NFC tag to expose a text record to NFC polling devices. It uses the NFC Data Exchange Format (NDEF).</p> <p>When the sample starts, it initializes the NFC tag and generates an NDEF message with three text records that contain the text \u201cHello World!\u201d in three languages. Then it sets up the NFC library to use the generated message and sense the external NFC field.</p> <p>The only events handled by the application are the NFC events. The Green LED turns on when an NFC field is present.</p>"},{"location":"guides/ncs/samples/nfc/text_record/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>A 13.56MHz NFC Antenna</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with NFC support</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/nfc/text_record/#wiring-the-nfc-antenna","title":"Wiring the NFC antenna","text":""},{"location":"guides/ncs/samples/nfc/text_record/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the NFC Text record sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/nfc/record_text\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/text_record/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/text_record/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>Touch the NFC antenna with the smartphone or tablet and observe that Green LED is lit.</li> <li>Observe that the smartphone or tablet displays the encoded text (in the most suitable language).</li> <li>Move the smartphone or tablet away from the NFC antenna and observe that Green LED turns off.</li> </ol>"},{"location":"guides/ncs/samples/nfc/uri_record/","title":"NFC URI record","text":""},{"location":"guides/ncs/samples/nfc/uri_record/#overview","title":"Overview","text":"<p>The NFC URI record sample shows how to use the NFC tag to expose a URL record to NFC polling devices.  It uses the NFC Data Exchange Format (NDEF).</p> <p>When the sample starts, it initializes the NFC tag and generates a URI message with a URI record containing the URL \"https://makerdiary.com\". Then it sets up the NFC library to use the generated message and sense the external NFC field. </p> <p>The only events handled by the application are the NFC events. The Green LED turns on when an NFC field is present.</p>"},{"location":"guides/ncs/samples/nfc/uri_record/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>A 13.56MHz NFC Antenna</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with NFC support</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/nfc/uri_record/#wiring-the-nfc-antenna","title":"Wiring the NFC antenna","text":""},{"location":"guides/ncs/samples/nfc/uri_record/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the NFC URI record sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/nfc/record_uri\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/uri_record/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/uri_record/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>Touch the NFC antenna with the smartphone or tablet and observe that Green LED is lit.</li> <li>Observe that the smartphone or tablet tries to open the URL \"https://makerdiary.com\" in a web browser.</li> <li>Move the smartphone or tablet away from the NFC antenna and observe that Green LED turns off.</li> </ol>"},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/","title":"NFC Writable NDEF message","text":""},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#overview","title":"Overview","text":"<p>The Writable NDEF message sample shows how to use the NFC tag to expose an NDEF message that can be overwritten with any other NDEF message by an NFC device. It uses the NFC Data Exchange Format (NDEF).</p> <p>When the sample starts, it initializes the NFC tag and loads the NDEF message from the file in flash memory. If the NDEF message file does not exist, a default message is generated. It is a URI message with a URI record containing the URL \u201chttps://makerdiary.com\u201d. The sample then sets up the NFC library for the Type 4 Tag platform, which uses the NDEF message and senses the external NFC field.</p> <p>The library works in Read-Write emulation mode. In this mode, procedures for reading and updating an NDEF message are handled internally by the NFC library. Any changes to the NDEF message update the NDEF message file stored in flash memory.</p>"},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>A 13.56MHz NFC Antenna</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with NFC support</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#installing-nfc-tools-app","title":"Installing NFC Tools App","text":"<p>NFC Tools App can read and write your NFC tags with a simple and lightweight user interface.</p> <p> </p>"},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#wiring-the-nfc-antenna","title":"Wiring the NFC antenna","text":""},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Writable NDEF message sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/nfc/writable_ndef_msg\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/nfc/writable_ndef_msg/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Power up nRF52840 Connect Kit by using the USB-C Cable.</li> <li>Touch the NFC antenna with the smartphone or tablet and observe that Green LED is lit.</li> <li>Observe that the smartphone or tablet tries to open the URL \"https://makerdiary.com\" in a web browser.</li> <li>Use NFC Tools to overwrite the existing NDEF message with your own message.</li> <li>Restart your board and touch the antenna again. Observe that the new message is displayed.</li> </ol>"},{"location":"guides/ncs/samples/thread/cli/","title":"Thread CLI","text":"<p>The Thread CLI sample demonstrates how to send commands to a Thread device using the OpenThread Command Line Interface (CLI). The CLI is integrated into the Zephyr shell.</p> <p>Sniffing packets from a Thread network</p> <p>You can use nRF Sniffer for 802.15.4 to capture and analyze packets exchanged on a Thread network.</p>"},{"location":"guides/ncs/samples/thread/cli/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>2x nRF52840 Connect Kit</li> <li>2x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/thread/cli/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Thread CLI sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> DefaultLow power modeMultiprotocol <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/cli\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/cli -- -DOVERLAY_CONFIG=overlay-low_power.conf -DDTC_OVERLAY_FILE=low_power.overlay\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/cli -- -DOVERLAY_CONFIG=overlay-multiprotocol.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/cli/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/cli/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the board:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>Configure the required Thread network parameters with the <code>ot channel</code>, <code>ot panid</code>, and <code>ot networkkey</code> commands. Make sure to use the same parameters for all nodes that you add to the network. The following example uses the default OpenThread parameters:</p> <pre><code>uart:~$ ot channel 11\nDone\nuart:~$ ot panid 0xabcd\nDone\nuart:~$ ot networkkey 00112233445566778899aabbccddeeff\nDone\n</code></pre> </li> <li> <p>Enable the Thread network with the <code>ot ifconfig up</code> and <code>ot thread start</code> commands:</p> <pre><code>uart:~$ ot ifconfig up\nDone\nuart:~$ ot thread start\nDone\n</code></pre> </li> <li> <p>Invoke some of the OpenThread commands:</p> <ol> <li> <p>Test the state of the Thread network with the <code>ot state</code> command. For example:</p> <pre><code>uart:~$ ot state\nleader\nDone\n</code></pre> </li> <li> <p>Get the Thread network name with the <code>ot networkname</code> command. For example:</p> <pre><code>uart:~$ ot networkname\nOpenThread\nDone\n</code></pre> </li> <li> <p>Get the IP addresses of the current Thread network with the <code>ot ipaddr</code> command. For example:</p> <pre><code>uart:~$ ot ipaddr\nfdde:ad00:beef:0:0:ff:fe00:fc00\nfdde:ad00:beef:0:0:ff:fe00:1000\nfdde:ad00:beef:0:a5b3:5dbd:97b2:474b\nfe80:0:0:0:3cae:981b:5d24:3f00\nDone\n</code></pre> </li> </ol> </li> <li> <p>Test communication between the kits with the following command:</p> <pre><code>ot ping ip_address_of_the_first_kit\n</code></pre> <p>For example:</p> <pre><code>uart:~$ ot ping fdde:ad00:beef:0:a5b3:5dbd:97b2:474b\n16 bytes from fdde:ad00:beef:0:a5b3:5dbd:97b2:474b: icmp_seq=1 hlim=64 time=24ms\n1 packets transmitted, 1 packets received. Packet loss = 0.0%. Round-trip min/avg/max = 24/24.0/24 ms.\nDone\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/thread/coap/","title":"Thread CoAP Client","text":""},{"location":"guides/ncs/samples/thread/coap/#overview","title":"Overview","text":"<p>This section of the documentation explains how to set up a basic OpenThread network composed of the Thread CoAP Client and Server:</p> <ul> <li>Thread CoAP Client demonstrates how to use Zephyr CoAP API for communication to access resources available on a Thread server node. The client supports Multiprotocol Bluetooth LE extension which uses the Nordic UART Service (NUS) library to control the LED states over Bluetooth\u00ae LE in a Thread network.</li> <li> <p>Thread CoAP Server demonstrates how to expose resources that can be accessed by other devices in the same Thread network. The following CoAP resources are exposed on the network by this sample:</p> <ul> <li><code>/light</code> - used to control Green LED</li> <li><code>/provisioning</code> - used to perform provisioning</li> </ul> </li> </ul> <p>After the Thread network is established, the client node can control the state of Green LED on server nodes. It can turn on the LED either on every server node in the network with a multicast message, or on a single specific server node that is paired with the client node.</p> <p>Sniffing packets from a Thread network</p> <p>You can use nRF Sniffer for 802.15.4 to capture and analyze packets exchanged on a Thread network.</p>"},{"location":"guides/ncs/samples/thread/coap/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>2x nRF52840 Connect Kits</li> <li>2x USB-C Cable</li> <li>A smartphone or a tablet with nRF Toolbox installed</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/thread/coap/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the samples on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build each sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> Thread CoAP ClientThread CoAP Server <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/coap_client -- -DOVERLAY_CONFIG=overlay-multiprotocol_ble.conf\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/coap_server\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/coap/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The samples are designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> <li> <p>Repeat the steps above to flash the client and server board.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/coap/#testing","title":"Testing","text":"<p>After flashing the firmware to your boards, complete the following steps to test it:</p> <ol> <li>Turn on the board that runs the Thread CoAP Server sample. Wait until the server's RGB LED turns Green. It will create a Thread network and this node becomes the Thread network Leader.</li> <li>Turn on the board that runs the Thread CoAP Client sample.</li> <li>Wait until the client's RGB LED turns Green. The client enters the network as a Child, and gradually becomes a Router.</li> <li>Start the nRF Toolbox app, tap UART to open the UART application.</li> <li>Connect to the device with the name NUS_CoAP_client discovered in the UART application.</li> <li> <p>Tap the blank buttons to create new commands. The following command assignments are configured with EOL set to LF :</p> <ul> <li>u - Send a unicast CoAP message over Thread.</li> <li>m - Send a multicast CoAP message over Thread.</li> <li>p - Send a pairing request as CoAP message over Thread.</li> </ul> <p> </p> </li> <li> <p>Tap the m command button to send a multicast <code>LIGHT_ON</code> or <code>LIGHT_OFF</code> message (alternatively) to the <code>/light</code> resource. Observe that the Green LED on the server node turns on or off.</p> </li> <li> <p>Pair a client with a server by completing the following steps:</p> <ol> <li>Press USER button on a server node to enable pairing.</li> <li>Tap the p command button to pair the client with the server node in the pairing mode.</li> </ol> </li> <li> <p>Tap the u command button to send a unicast <code>LIGHT_TOGGLE</code> message to the <code>/light</code> resource on the paired server node.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/coprocessor/","title":"Thread Co-processor","text":""},{"location":"guides/ncs/samples/thread/coprocessor/#overview","title":"Overview","text":"<p>The Thread Co-processor sample demonstrates how to implement OpenThread\u2019s Co-processor designs inside the Zephyr environment. The sample uses the Radio co-processor (RCP) architecture.</p> <p>The sample is based on Zephyr\u2019s OpenThread Co-Processor sample. However, it customizes Zephyr\u2019s sample to fulfill the nRF Connect SDK requirements (for example, by increasing the stack size dedicated for the user application), and also extends it with features such as:</p> <ul> <li>Increased Mbed TLS heap size.</li> <li>Lowered main stack size to increase user application space.</li> <li>No obsolete configuration options.</li> <li>Vendor hooks for co-processor architecture allowing users to extend handled properties by their own, customized functionalities.</li> <li>Thread 1.2 features.</li> </ul> <p>Sniffing packets from a Thread network</p> <p>You can use nRF Sniffer for 802.15.4 to capture and analyze packets exchanged on a Thread network.</p>"},{"location":"guides/ncs/samples/thread/coprocessor/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> <li>Python v3.6 or later</li> </ul>"},{"location":"guides/ncs/samples/thread/coprocessor/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Thread Co-processor sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> DefaultVendor hooks support <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/coprocessor\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/openthread/coprocessor -- -DOVERLAY_CONFIG=overlay-vendor_hook.conf\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/coprocessor/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/thread/coprocessor/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Get the board\u2019s serial port name (for example, <code>/dev/cu.usbmodem14201</code>).</li> <li> <p>Build the OpenThread POSIX applications by performing the following steps:</p> <ol> <li> <p>Enter the <code>openthread</code> directory:</p> <pre><code>cd modules/lib/openthread\n</code></pre> </li> <li> <p>Install the OpenThread dependencies:</p> <pre><code>./script/bootstrap\n</code></pre> </li> <li> <p>Build the <code>ot-daemon</code> and <code>ot-ctl</code> applications with support for Thread v1.2:</p> <pre><code>./script/cmake-build posix -DOT_THREAD_VERSION=1.2 -DOT_DAEMON=ON\n</code></pre> </li> </ol> <p>You can find the generated applications in <code>./build/posix/src/posix/</code>.</p> </li> <li> <p>Open up a terminal window, and start <code>ot-daemon</code> with the <code>--verbose</code> flag so you can see log output and confirm that it is running:</p> <pre><code>sudo ./build/posix/src/posix/ot-daemon 'spinel+hdlc+uart:///dev/cu.usbmodem14201?uart-baudrate=115200' --verbose\n</code></pre> <p>When successful, <code>ot-daemon</code> in verbose mode generates output similar to the following:</p> <pre><code>Feb 10 16:51:15  ./build/posix/src/posix/ot-daemon[56466] &lt;Info&gt;: Running OPENTHREAD/632b63089; POSIX; Feb 10 2023 16:31:19\nFeb 10 16:51:15  ./build/posix/src/posix/ot-daemon[56466] &lt;Info&gt;: Thread version: 3\nFeb 10 16:51:15  ./build/posix/src/posix/ot-daemon[56466] &lt;Info&gt;: Thread interface: utun4\nFeb 10 16:51:15  ./build/posix/src/posix/ot-daemon[56466] &lt;Info&gt;: RCP version: OPENTHREAD/632b63089; Zephyr; Feb 10 2023 16:50:38\n</code></pre> </li> <li> <p>Open up a second terminal window and use <code>ot-ctl</code> to communicate with the RCP node, specifying the Thread interface <code>utun4</code> shown in <code>ot-daemon</code> log output:</p> <pre><code>sudo ./build/posix/src/posix/ot-ctl -I utun4\n</code></pre> </li> <li> <p>From this point, you can follow the Testing instructions in the CLI sample by removing the <code>ot</code> prefix for each command. For example:</p> <pre><code>&gt; state\nstate\ndisabled\nDone\n&gt; channel\nchannel\n11\nDone\n&gt; panid 0xabcd\npanid 0xabcd\nDone\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/usb/hid_mouse/","title":"USB HID Mouse","text":""},{"location":"guides/ncs/samples/usb/hid_mouse/#overview","title":"Overview","text":"<p>The USB HID Mouse sample demonstrates the use of a USB Human Interface Device (HID) driver by the Zephyr project. This very simple driver enumerates a board with a button into a mouse that has a left mouse button and optionally (depending on the number of buttons on the board) a right mouse button, X-axis movement, and Y-axis movement. If the USB peripheral driver supports remote wakeup feature, wakeup request will be performed on every button click if the bus is in suspended state.</p>"},{"location":"guides/ncs/samples/usb/hid_mouse/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/usb/hid_mouse/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the USB HID Mouse sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/usb/hid-mouse\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/usb/hid_mouse/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/usb/hid_mouse/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>The board will be detected as a HID mouse named Zephyr HID mouse sample.</li> <li>Press USER button on the board. Observe that a left mouse click is activated.</li> </ol>"},{"location":"guides/ncs/samples/usb/mass/","title":"USB Mass Storage","text":""},{"location":"guides/ncs/samples/usb/mass/#overview","title":"Overview","text":"<p>The USB Mass Storage sample demonstrates the use of a USB Mass Storage driver by the Zephyr project. This very simple driver enumerates a board with either RAM or FLASH into an USB disk.</p>"},{"location":"guides/ncs/samples/usb/mass/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/usb/mass/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the USB Mass Storage sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>. There are multiple configurations can be chosen:</p> RAM-diskRAM-disk with FATFSFLASH-disk with FATFSFLASH-disk with LittleFS <pre><code>west build -p always -b connectkit_nrf52840 samples/usb/mass\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/usb/mass -- -DCONFIG_APP_MSC_STORAGE_RAM=y\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/usb/mass -- -DCONFIG_APP_MSC_STORAGE_FLASH_FATFS=y\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/usb/mass -- -DCONFIG_APP_MSC_STORAGE_FLASH_LITTLEFS=y\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/usb/mass/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/usb/mass/#testing","title":"Testing","text":"<p>After flashing the firmware to your board, complete the following steps to test it:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>The board will be detected as an USB disk.</li> </ol> <p>LittleFS Usage</p> <p>While a FAT-based file system can be mounted by many systems automatically, mounting the littlefs file system on a Linux or FreeBSD system can be accomplished using the littlefs-fuse utility.</p>"},{"location":"guides/ncs/samples/zigbee/lighting/","title":"Zigbee Lighting","text":""},{"location":"guides/ncs/samples/zigbee/lighting/#overview","title":"Overview","text":"<p>This section of the documentation explains how to set up a basic Zigbee network composed of three devices:</p> <ul> <li>Zigbee Network coordinator demonstrates the Zigbee Coordinator role and supports only the network steering commissioning mechanism.</li> <li>Zigbee Light bulb demonstrates the Zigbee Router role and implements the Dimmable Light device specification, as defined in the Zigbee Home Automation public application profile.</li> <li>Zigbee Light switch demonstrates the Zigbee End Device role and implements the Dimmer Switch device specification, as defined in the Zigbee Home Automation public application profile. Once commissioned into the network, it looks for devices with the implemented Level Control and On/Off clusters and can control the one that answers first. The light switch also supports Multiprotocol Bluetooth LE extension which uses the Nordic UART Service (NUS) library to control the light bulb states over Bluetooth\u00ae LE in a Thread network.</li> </ul> <p>Sniffing packets from a Zigbee network</p> <p>You can use nRF Sniffer for 802.15.4 to capture and analyze packets exchanged on a Zigbee network.</p>"},{"location":"guides/ncs/samples/zigbee/lighting/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>3x nRF52840 Connect Kit</li> <li>3x USB-C Cable</li> <li>A smartphone or a tablet with nRF Toolbox installed</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/zigbee/lighting/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the samples on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build each sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> Network coordinatorLight bulbLight switch <pre><code>west build -p always -b connectkit_nrf52840 samples/zigbee/network_coordinator\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/zigbee/light_bulb\n</code></pre> <pre><code>west build -p always -b connectkit_nrf52840 samples/zigbee/light_switch\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/lighting/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The samples are designed to work with the UF2 Bootloader, so that you can easily flash each sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> <li> <p>Repeat the steps above to flash the Network coordinator, Light bulb and Light switch.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/lighting/#testing","title":"Testing","text":"<p>After flashing the Network coordinator, Light bulb and Light switch, complete the following steps to test the demo:</p> <ol> <li>Turn on the board that runs the Zigbee Network coordinator sample. When the RGB LED turns blue, this board has become the Coordinator of the Zigbee network and the network is established.</li> <li> <p>Turn on the board that runs the Zigbee Light bulb sample. When RGB LED turns blue, the light bulb has become a Router inside the network.</p> <p>Note</p> <p>If RGB LED on the light bulb does not turn blue, RESET the Coordinator to reopen the network.</p> </li> <li> <p>Turn on the board that runs the Zigbee Light switch sample. When RGB LED turns blue, the light switch has become an End Device, connected directly to the Coordinator.</p> </li> <li>Wait until Green LED on the light switch node turns on. This LED indicates that the light switch found a light bulb to control.</li> <li>Start the nRF Toolbox app, tap UART to open the UART application.</li> <li>Connect to the device with the name Zigbee_Switch discovered in the UART application.</li> <li> <p>Tap the blank buttons to create new commands. The following command assignments are configured with EOL set to LF :</p> <ul> <li>n - Turn on the Zigbee Light bulb.</li> <li>f - Turn off the Zigbee Light bulb.</li> <li>t - Toggle the Zigbee Light bulb on or off.</li> <li>i - Increase the brightness level of the Zigbee Light bulb.</li> <li>d - Decrease the brightness level of the Zigbee Light bulb.</li> </ul> <p> </p> </li> <li> <p>In nRF Toolbox UART, tap the buttons you assigned:</p> <ol> <li>Tap the n and f command buttons to turn the LED on the Zigbee Light bulb node on and off, respectively.</li> <li>Tap the t command button to toggle the LED on the Zigbee Light bulb node on and off.</li> <li>Tap the i and d command buttons to make adjustments to the brightness level.</li> </ol> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/ncp/","title":"Zigbee NCP","text":""},{"location":"guides/ncs/samples/zigbee/ncp/#overview","title":"Overview","text":"<p>The Zigbee NCP sample demonstrates the usage of Zigbee\u2019s Network Co-Processor (NCP) architecture.</p> <p>Together with the source code from ZBOSS NCP Host, you can use this sample to create a complete and functional Zigbee device. For example, as shown in the Testing section, you can program nRF52840 Connect Kit with the NCP sample and bundle it with the simple gateway application on the NCP host processor.</p> <p>You can then use this sample together with the Zigbee Light bulb to set up a basic Zigbee network.</p> <p>Sniffing packets from a Zigbee network</p> <p>You can use nRF Sniffer for 802.15.4 to capture and analyze packets exchanged on a Zigbee network.</p>"},{"location":"guides/ncs/samples/zigbee/ncp/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>2x nRF52840 Connect Kit</li> <li>2x USB-C Cable</li> <li>A computer running 64-bit Ubuntu 18.04 Linux</li> </ul>"},{"location":"guides/ncs/samples/zigbee/ncp/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Zigbee NCP sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build the sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/zigbee/ncp\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/ncp/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/ncp/#testing","title":"Testing","text":"<p>After flashing the Zigbee NCP firmware, complete the following steps to test it:</p> <ol> <li> <p>Download and extract the ZBOSS NCP Host package.</p> <p>Note</p> <p>If you are using a Linux distribution different than the 64-bit Ubuntu 18.04, make sure to rebuild the package libraries and applications. Follow the instructions in the Rebuilding the ZBOSS libraries for host section in the NCP Host documentation.</p> </li> <li> <p>Connect the board that runs the Zigbee NCP firmware to your computer using the USB-C Cable.</p> </li> <li>Get the kit\u2019s serial port names. You will get two serial ports: one used for communication with the NCP Host and one used to print ZBOSS stack logs.</li> <li>Turn on the board that runs the Zigbee Light bulb sample.</li> <li> <p>To start the simple gateway application, run the following command with <code>serial_port_name</code> replaced with the serial port name used for communication with the NCP sample:</p> <pre><code>NCP_SLAVE_PTY=*serial_port_name* ./application/simple_gw/simple_gw\n</code></pre> </li> <li> <p>The simple gateway device forms the Zigbee network and opens the network for 180 seconds for new devices to join. When the light bulb joins the network, the RGB LED on the light bulb device turns Blue to indicate that it is connected to the simple gateway. The gateway then starts discovering the On/Off cluster. When it is found, the simple gateway configures bindings and reporting for the device. It then starts sending On/Off toggle commands with a 15-second interval that toggle the Green LED on the light bulb on and off.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/shell/","title":"Zigbee Shell","text":""},{"location":"guides/ncs/samples/zigbee/shell/#overview","title":"Overview","text":"<p>This Zigbee Shell sample demonstrates a Zigbee router (with the possibility of being a coordinator) that uses the Zigbee shell library for interaction.</p> <p>You can use this sample for several purposes, including:</p> <ul> <li>Initial configuration of the network - forming a network as coordinator, adding devices to the network with the install codes, setting the extended PAN ID.</li> <li>Benchmarking - measuring time needed for a message to travel from one node to another.</li> </ul>"},{"location":"guides/ncs/samples/zigbee/shell/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>2x nRF52840 Connect Kit</li> <li>2x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/ncs/samples/zigbee/shell/#building-the-sample","title":"Building the sample","text":"<p>Before you start building, remember to set up the environment first.</p> <p>Use the following steps to build the Zigbee Shell sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>my-workspace/ncs-playground</code> directory created in the Setting up the environment section.</p> <pre><code>cd my-workspace/ncs-playground\n</code></pre> </li> <li> <p>Build each sample using the <code>west</code> command, specifying the board (following the <code>-b</code> option) as <code>connectkit_nrf52840</code>:</p> <pre><code>west build -p always -b connectkit_nrf52840 samples/zigbee/shell\n</code></pre> <p>Tip</p> <p>The <code>-p always</code> option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> </li> <li> <p>After running the <code>west build</code> command, the build files can be found in <code>build/zephyr</code>.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/shell/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The sample is designed to work with the UF2 Bootloader, so that you can easily flash the sample using the UF2 Bootloader. The firmware can be found in <code>build/zephyr</code> with the name <code>zephyr.uf2</code>.</p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the sample will start running.</p> </li> </ol>"},{"location":"guides/ncs/samples/zigbee/shell/#testing","title":"Testing","text":"<p>After flashing the Zigbee Shell firmware, complete the following steps to test it:</p> <ol> <li> <p>Connect the first shell device to your computer using the USB-C Cable.</p> </li> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the first shell device:</p> macOS/LinuxWindows <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> </li> <li> <p>To set the first shell device to work as coordinator, run the following shell command:</p> <pre><code>bdb role zc\n</code></pre> <p>This shell device is now the shell coordinator node.</p> </li> <li> <p>Run the following command on this shell coordinator node to start a new Zigbee network:</p> <pre><code>bdb start\n</code></pre> </li> <li> <p>Run the following command on the second shell device:</p> <pre><code>bdb start\n</code></pre> <p>This shell device joins the network.</p> </li> <li> <p>To acquired short address of the second shell device, run the following command:</p> <pre><code>zdo short\n</code></pre> <p>You should see the output, similar to the following:</p> <pre><code>uart:~$ zdo short\n50b4\nDone\n</code></pre> </li> <li> <p>To check the communication between the nodes, issue a ping request on the coordinator with the acquired short address value and the payload size:</p> <pre><code>zcl ping zdo_short_address payload_size\n</code></pre> <p>For example:</p> <pre><code>zcl ping 0x50b4 10\n</code></pre> <p>The ping time response is returned when the ping is successful, followed by the additional information from the endpoint logger. For example:</p> <pre><code>uart:~$ zcl ping 0x50b4 10\nPing time: 17 ms\nDone\n[00:08:20.789,245] &lt;inf&gt; zigbee.eprxzcl: Received ZCL command (0): src_addr=0x50b4(short) src_ep=64 dst_ep=64 cluster_id=0xbeef profile_id=0x0104 cmd_dir=0 common_cmd=0 cmd_id=0x01 cmd_seq=0 disable_def_resp=1 manuf_code=void payload=[cdcdcdcdcdcdcdcdcdcd] (0)\n</code></pre> <p>Tip</p> <p>To disable the logs from Zigbee endpoint logger:</p> <pre><code>log disable zigbee.eprxzcl\n</code></pre> <p>To enable logs from Zigbee endpoint logger and set its logging to the info level (<code>inf</code>)</p> <pre><code>log enable inf zigbee.eprxzcl\n</code></pre> </li> </ol>"},{"location":"guides/nrf802154-sniffer/","title":"nRF Sniffer for 802.15.4","text":""},{"location":"guides/nrf802154-sniffer/#introduction","title":"Introduction","text":"<p>The nRF Sniffer for 802.15.4 is a tool for learning about and debugging applications that are using protocols based on IEEE 802.15.4, such as Thread and Zigbee. It provides a near real-time display of 802.15.4 packets that are sent back and forth between devices, even when the link is encrypted.</p> <p>When developing a 802.15.4-compatible product, knowing what happens over-the-air between devices can help you identify and fix issues quickly.</p> <p>The nRF Sniffer captures packets transmitted by nearby devices on a selected radio channel. You can start the capture manually from Wireshark, a free software tool that captures wireless traffic and reproduces it in a readable format, or using a Python script. Use either of these methods to create packet capture files, from which you can extract data in Wireshark. This data can include destination and source addresses, personal area network identifiers, and packet payloads.</p> <p>The nRF Sniffer for 802.15.4 comes with an extcap plugin for capturing packets in Wireshark. This plugin can also be installed as a Python module for use in a script.</p> <p>Wireshark is also able to analyze data exchanged over higher-level protocols, such as Thread and Zigbee. You can configure the Sniffer to report out-of-band metadata, such as channel, received signal strength indicator (RSSI), and link quality inidcator (LQI).</p>"},{"location":"guides/nrf802154-sniffer/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>Supported operating systems:<ul> <li>Windows 10</li> <li>64-bit OS X/macOS 10.6 or later</li> <li>Linux (check the Wireshark prerequisites for version compatibility)</li> </ul> </li> <li>Wireshark v3.4.7 or later</li> <li>Python v3.7 or later</li> </ul>"},{"location":"guides/nrf802154-sniffer/#get-involved","title":"Get Involved","text":"<p>The following sections explain how to set up the nRF Sniffer for 802.15.4 and help you get moving with sniffing:</p> <ul> <li>Installation</li> <li>Configuring Wireshark for nRF Sniffer for 802.15.4</li> <li>Capturing data with the nRF Sniffer</li> <li>Inspecting captured data</li> </ul>"},{"location":"guides/nrf802154-sniffer/#reference","title":"Reference","text":"<ul> <li>nRF Sniffer for 802.15.4 User Guide v0.7.2</li> <li>Wireshark website</li> </ul>"},{"location":"guides/nrf802154-sniffer/capturing/","title":"Capturing data with the nRF Sniffer","text":"<p>You can start capturing manually from Wireshark or using a Python script.</p> <p>The nRF Sniffer for 802.15.4 listens on the specified channel to pick up as many packets as possible from as many devices as possible. The default channel is 11. To listen on a different channel, you can either run nRF Sniffer with custom options (if you are starting the capturing process manually) or set the specific channel when integrating the nRF Sniffer module into your script (if you are running the capture from a script).</p>"},{"location":"guides/nrf802154-sniffer/capturing/#setting-up-hardware-for-nrf-sniffer","title":"Setting up hardware for nRF Sniffer","text":"<p>Before you start sniffing, place the nRF52840 Connect Kit that runs the nRF Sniffer for 802.15.4 firmware near the devices that are communicating. The hardware setup is the same for all supported methods of capturing data, whether Wireshark or a custom Python script.</p> <p>Connect the nRF52840 Connect Kit to your computer and turn it on. Then place it next to the devices that you want to sniff.</p> <p></p>"},{"location":"guides/nrf802154-sniffer/capturing/#capturing-data-in-wireshark","title":"Capturing data in Wireshark","text":"<p>You can start capture manually from Wireshark with or without the out-of-band metadata. Capturing in Wireshark requires installing an nRF Sniffer plugin.</p>"},{"location":"guides/nrf802154-sniffer/capturing/#running-nrf-sniffer-in-wireshark","title":"Running nRF Sniffer in Wireshark","text":"<p>To start sniffing, open Wireshark and start recording packets.</p> <p>When you open Wireshark, the Wireshark main window appears. It includes the Wireshark hardware interfaces connected to the nRF Sniffer.</p> <p></p> <p>To start sniffing with the default settings, use one of the following options:</p> <ul> <li>Double-click on the nRF Sniffer for 802.15.4 hardware interface.</li> <li>Select the nRF Sniffer for 802.15.4 hardware interface and click the Capture packets button.</li> </ul> <p>By default, both these options start the capturing process on channel 11 without capturing the out-of-band metadata. If you want to capture this kind of data or listen on a different channel, run nRF Sniffer with custom options.</p> <p>Wireshark begins capturing data from the nRF Sniffer for 802.15.4 hardware interface, allowing you to inspect captured data.</p>"},{"location":"guides/nrf802154-sniffer/capturing/#running-nrf-sniffer-in-wireshark-with-custom-options","title":"Running nRF Sniffer in Wireshark with custom options","text":"<p>To start listening on a custom channel and with custom out-of-band metadata settings, run the capturing tool in Wireshark from the Interface Options window.</p> <p>To start sniffing:</p> <ol> <li> <p>In the main window of Wireshark, click  next to the nRF Sniffer for 802.15.4 hardware interface entry to open the Interface Options menu.</p> </li> <li> <p>In you want to specify the Channel on which the packets are to be captured, use the Channel dropdown menu to select it.</p> </li> <li> <p>If you want to get additional out-of-band metadata, use the Out-Of-Band meta-data drop-down menu to select IEEE 802.15.4 TAP.</p> <p></p> </li> <li> <p>Optionally, you can check the Save parameter(s) on capture start option to save the settings for future captures. Keeping this option unchecked will reset the settings to the default values for the next capture.</p> </li> <li> <p>Click Start to run nRF Sniffer.</p> </li> </ol> <p>Wireshark begins capturing data from the nRF Sniffer for 802.15.4 hardware interface, allowing you to inspect captured data.</p>"},{"location":"guides/nrf802154-sniffer/capturing/#capturing-data-using-a-script","title":"Capturing data using a script","text":"<p>The nRF Sniffer for 802.15.4 can be used in Python scripts to capture packets into a <code>pcap</code> file, which you can then open and inspect in Wireshark. Using this option requires installing the capture plugin as a Python module and then integrating it into your script.</p>"},{"location":"guides/nrf802154-sniffer/capturing/#installing-the-nrf-sniffer-python-module","title":"Installing the nRF Sniffer Python module","text":"<p>You can install the capture tool as a Python module and use this module programmatically in custom Python scripts. The module exposes an API that allows you to start and stop the capture.</p> <p>To install the nRF Sniffer Python module, complete the following steps:</p> <ol> <li>Open a command window in the <code>tools/nrf802154_sniffer/</code> folder.</li> <li> <p>Install the script by typing the following command:</p> WindowsLinux/macOS <pre><code>py -3 -m pip install .\n</code></pre> <pre><code>python3 -m pip install .\n</code></pre> </li> </ol> <p>Then integrate this module into your custom Python script and use it alongside the nRF Sniffer hardware.</p>"},{"location":"guides/nrf802154-sniffer/capturing/#integrating-nrf-sniffer-python-module-into-a-script","title":"Integrating nRF Sniffer Python module into a script","text":"<p>In your script, include the nRF Sniffer Python module and specify the parameters for the API function that starts the capture process. These mandatory and optional parameters define what packets are saved to the pcap file.</p> <p>To integrate the nRF Sniffer Python module into your script:</p> <ol> <li> <p>Open your custom Python script and include the nRF Sniffer module:</p> <pre><code>from nrf802154_sniffer import Nrf802154Sniffer\n</code></pre> </li> <li> <p>Check the name of the port to which you connected the nRF Sniffer device. The name is used to set the <code>dev</code> parameter.</p> </li> <li> <p>Check the number of the channel on which you want to listen for packets. The number is used to set the <code>channel</code> parameter.</p> </li> <li> <p>At the point in your script where you want to start the capture process, add the following lines to start the capture. Use the parameter values from the previous steps. For example:</p> <pre><code>sniffer = Nrf802154Sniffer()\nsniffer.extcap_capture(fifo=\"file.pcap\", dev=\"/dev/ttyACM3\", channel=26)\n</code></pre> <p>In this code, the nRF Sniffer script captures packets from the sniffer on port <code>/dev/ttyACM3</code> on the channel <code>26</code> and saves the results to the <code>file.pcap</code> file.</p> <p>See the following table for the description of all parameters of the <code>extcap_capture()</code> function and their possible values.</p> Parameter Type Description fifo Mandatory Defines the name of the pcap file to which the captured packets will be saved. The parameter value can also include the path to the file directory if you want to save it in a custom directory. By default, the script saves the file in the working directory. dev Mandatory Defines the serial port used to communicate with the nRF Sniffer hardware. channel Mandatory Specifies the 802.15.4 radio channel number on which the nRF Sniffer listens for packets. metadata Optional Specifies the metadata type for the packet capture. Use <code>ieee802154-tap</code>. control_in Unused Specifies a file that Wireshark is going to use to control the capture plugin during run time. Currently unused. control_out Unused Specifies a file that Wireshark is going to use to control the capture plugin during run time. Currently unused. </li> <li> <p>At the point in your script where you want to stop the capture process, add the following lines:</p> <pre><code>sniffer.stop_sig_handler()\n</code></pre> <p>Note</p> <p>You can add the lines that start and stop the script multiple times in your script. Make sure to stop the capture before you start a new capture process.</p> </li> </ol> <p>When you run the script with the nRF Sniffer hardware, the nRF Sniffer captures packets and saves the results into the <code>pcap</code> file. Open this file in Wireshark to inspect captured data.</p>"},{"location":"guides/nrf802154-sniffer/configuring/","title":"Configuring Wireshark for the nRF Sniffer","text":"<p>The nRF Sniffer for 802.15.4 must be configured for capturing and analyzing packets exchanged on Thread and Zigbee networks.</p>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-wireshark-for-thread","title":"Configuring Wireshark for Thread","text":"<p>Capturing packets on a Thread network requires configuring at least the IEEE 802.15.4 decryption keys. Additionally, you can also configure the CoAP port and the 6loWPAN settings.</p>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-decryption-keys-for-thread","title":"Configuring decryption keys for Thread","text":"<p>You must configure IEEE 802.15.4 decryption keys to decode packets exchanged on the network and display the data in a readable format.</p> <p>You need to know the Thread decryption key before you start configuring it in Wireshark. For example, if one of the devices in the Thread network has the OpenThread CLI enabled, you can check the decryption key by calling the <code>masterkey</code> CLI command.</p> <p>To configure the decryption keys:</p> <ol> <li>In Wireshark, go to Edit &gt; Preferences... (on Windows or Linux) or Wireshark &gt; Preferences... (on macOS).</li> <li> <p>In the Preferences section list, go to Protocols &gt; IEEE 802.15.4.</p> <p></p> </li> <li> <p>Click the Edit... button next to Decryption Keys.</p> </li> <li> <p>In the Keys window:</p> <ol> <li> <p>Click + and add the Decryption key value with Decryption key index set to <code>0</code> and Key hash set to <code>Thread hash</code>.</p> <p></p> </li> <li> <p>Click OK to close the window.</p> </li> </ol> </li> <li> <p>Click OK to save the decryption keys for Thread.</p> </li> </ol>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-coap-port-for-thread","title":"Configuring CoAP port for Thread","text":"<p>The Thread network uses the CoAP protocol on port 61631 for network management. You must configure this port in Wireshark if you want to correctly decode network management packets sent over this port.</p>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-coap-port-using-decode-as","title":"Configuring CoAP port using Decode As","text":"<p>You can apply the CoAP protocol settings once on a per-capture basis using the Decode As option.</p> <p>To configure the CoAP port using this option:</p> <ol> <li>In Wireshark, go to Analyze &gt; Decode As....</li> <li> <p>In the Decode As... settings window, click the + button to add a new entry with the Field set to UDP port, Value set to 61631, and Current set to CoAP.</p> <p></p> </li> <li> <p>Click OK to save the Decode As... settings.</p> </li> </ol>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-coap-port-using-preferences","title":"Configuring CoAP port using Preferences","text":"<p>You can apply the CoAP protocol settings globally by defining the CoAP port number in Wireshark Preferences.</p> <p>To configure the CoAP port using this option:</p> <ol> <li>In Wireshark, go to Edit &gt; Preferences... (on Windows or Linux) or Wireshark &gt; Preferences... (on macOS).</li> <li> <p>In the Preferences section list, go to Protocols &gt; CoAP.</p> <p></p> </li> <li> <p>Set the CoAP UDP port to <code>61631</code>.</p> </li> <li>Click OK to save the CoAP port settings.</li> </ol>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-6lowpan-context","title":"Configuring 6loWPAN context","text":"<p>6loWPAN defines contexts that are used to shorten IPv6 addresses sent over-the-air. Configuring the 6loWPAN context ensures that the correct IPv6 address is displayed during packet analysis.</p> <p>You can configure different 6loWPAN contexts depending on the Thread Network Data.</p> <p>To configure the 6loWPAN contexts used by Thread examples:</p> <ol> <li>In Wireshark, go to Edit &gt; Preferences... (on Windows or Linux) or Wireshark &gt; Preferences... (on macOS).</li> <li>In the Preferences section list, go to Protocols &gt; 6loWPAN.</li> <li> <p>Set the following contexts to the provided values:</p> <ol> <li>In the Context 0 field, add <code>fdde:ad00:beef:0::/64</code>.</li> <li>In the Context 1 field, add <code>fd11:22::/64</code>.</li> </ol> <p></p> </li> <li> <p>Click OK to save the 6loWPAN contexts for Thread.</p> </li> </ol>"},{"location":"guides/nrf802154-sniffer/configuring/#disabling-unwanted-protocols","title":"Disabling unwanted protocols","text":"<p>If Wireshark uses incorrect dissectors to decode a Thread message, you can optionally disable unwanted protocols.</p> <p>To disable unwanted protocols when capturing data from a Thread network:</p> <ol> <li>In Wireshark, go to Analyze &gt; Enabled Protocols....</li> <li> <p>In the Enabled Protocols window, disable unwanted protocols by unchecking the field next to their name.</p> <p>For example, you might want to disable LwMesh, ZigBee, and ZigBee Green Power.</p> <p></p> </li> <li> <p>Click OK to save the settings.</p> </li> </ol>"},{"location":"guides/nrf802154-sniffer/configuring/#configuring-wireshark-for-zigbee","title":"Configuring Wireshark for Zigbee","text":"<p>Additional Wireshark configuration is required to start capturing data from Zigbee samples in the nRF Connect SDK or from Zigbee examples in the nRF5 SDK for Thread and Zigbee.</p> <p>To capture data from Zigbee examples and samples:</p> <ol> <li>In Wireshark, go to Edit &gt; Preferences... (on Windows or Linux) or Wireshark &gt; Preferences... (on macOS).</li> <li> <p>In the Preferences section list, go to Protocols &gt; ZigBee.</p> <p></p> </li> <li> <p>Click the Edit... button to add the preconfigured keys.</p> </li> <li> <p>In the Pre-configured Keys window:</p> <ol> <li>Click + and add the key <code>5A:69:67:42:65:65:41:6C:6C:69:61:6E:63:65:30:39</code> with Byte Order set to Normal and Label set to <code>ZigbeeAlliance09</code>.</li> <li> <p>Click + and add the key <code>ab:cd:ef:01:23:45:67:89:00:00:00:00:00:00:00:00</code> with Byte Order set to Normal and Label set to <code>Nordic Examples</code>.</p> <p></p> </li> <li> <p>Click OK to close the window.</p> </li> </ol> </li> <li> <p>Click OK to save the preferences for Zigbee.</p> </li> </ol>"},{"location":"guides/nrf802154-sniffer/inspecting-data/","title":"Inspecting captured data","text":"<p>The nRF Sniffer passes all 802.15.4 packets to Wireshark, where they are wrapped in a header containing useful meta-information not present in the packet itself. Wireshark dissects the packets and separates the actual packet from the meta-information.</p> <p>When you browse captured packets, select a packet in the packet list to show the breakdown of that packet in the packet details pane. The hexadecimal view of the packet is shown in the packet bytes pane. Click a value in the details to highlight it among the bytes, or click on the bytes to highlight it in the details.</p> <p></p>"},{"location":"guides/nrf802154-sniffer/inspecting-data/#using-display-filter-expression","title":"Using Display Filter Expression","text":"<p>Use display filters to display a chosen packet subset. To open the filter menu and construct a filter:</p> <ol> <li>Right-click the filtering bar.</li> <li> <p>Click Display Filter Expression....</p> <p></p> </li> </ol> <p>Most filters are based on the values of the packets, such as length or access address. The filter expressions use Boolean operators (<code>&amp;&amp;</code> <code>||</code> <code>==</code> <code>!=</code> <code>!</code>).</p> <p></p> <p>See the following table for some filter examples.</p> Display filter Description <code>wpan</code> Filter that displays all IEEE 802.15.4 traffic. <code>wpan.dst_pan</code> Filter that displays IEEE 802.15.4 packets that have a specific destination PAN. <code>wpan.dst16</code> Filter that displays short destination addresses of IEEE 802.15.4 frames. <code>wpan.dst64</code> Filter that displays long destination addresses of IEEE 802.15.4 frames. <code>wpan.src16</code> Filter that displays short source addresses of IEEE 802.15.4 frames. <code>wpan.src64</code> Filter that displays long source addresses of IEEE 802.15.4 frames. <code>ipv6</code>, <code>coap</code>, <code>dtls</code>, <code>udp</code> Examples of filters for packets that can be encountered on Thread and IP networks. <code>mle</code> Protocol filter that displays all Mesh Link Establishment traffic. Used for example by Thread."},{"location":"guides/nrf802154-sniffer/inspecting-data/#tips-and-tricks","title":"Tips and Tricks","text":"<p>The following tips can help when inspecting your data:</p> <ul> <li> <p>Turn any field in the packet details pane into a column. To do so:</p> <ol> <li>Right-click the value in the packet details.</li> <li>Click Apply as Column.</li> </ol> <p></p> </li> <li> <p>Apply a value as a filter to, for example, see only operations affecting a particular handle. To filter packets that have a specific value for some field:</p> <ol> <li>Right-click the value in the packet details.</li> <li>Click Apply as Filter.</li> <li>Click Selected.</li> </ol> </li> <li> <p>Save a set of captured packets to be able to look at them later. To do so:</p> <ol> <li>Click the Stop button to stop capturing packets.</li> <li>Click File &gt; Save As to save all packets, or click File &gt; Export Specified Packets to save a selection of packets.</li> </ol> </li> <li> <p>Clear the packet list and restart a capture by clicking the Restart button.</p> </li> </ul> <p>See the documentation on the Wireshark website for more information.</p>"},{"location":"guides/nrf802154-sniffer/installation/","title":"Installing nRF Sniffer for 802.15.4","text":"<p>The nRF Sniffer for 802.15.4 consists of firmware that is programmed onto a nRF52840 Connect Kit and a capture plugin for Wireshark that records and analyzes the detected data.</p>"},{"location":"guides/nrf802154-sniffer/installation/#programming-the-nrf-sniffer-firmware","title":"Programming the nRF Sniffer firmware","text":"<p>You must connect a nRF52840 Connect Kit running the nRF Sniffer firmware to your computer to be able to use the nRF Sniffer for 802.15.4.</p> <p>The nRF Sniffer firmware in <code>.uf2</code>-format is located in <code>firmware/nrf802154_sniffer/</code>.</p> <p>Download the latest firmware and complete the following steps to flash the firmware:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>nrf802154_sniffer_&lt;version&gt;.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the nRF Sniffer will start running.</p> </li> </ol>"},{"location":"guides/nrf802154-sniffer/installation/#installing-wireshark","title":"Installing Wireshark","text":"<p>To install Wireshark for your operating system, complete the following steps:</p> Windows/macOSUbuntu Linux <ol> <li>Go to the Wireshark download page.</li> <li>Click the release package for your operating system from the Stable Release list. The download starts automatically.</li> <li>Install the package.</li> </ol> <ol> <li>Download the Wireshark standard package or the latest stable PPA for Ubuntu Linux distribution from the Wireshark download page.</li> <li>Install the package on your computer.</li> <li>Answer <code>yes</code> when the installer asks you if non-superusers should be able to capture packets. This ensures that packet capture is available to all users in the wireshark system group.</li> <li>Add the correct user to the wireshark user group. For example, type <code>sudo usermod -a -G wireshark $USER</code>.</li> <li>Add the correct user to the dialout user group. For example, type <code>sudo usermod -a -G dialout $USER</code>.</li> <li>Restart your computer to apply the new user group settings.</li> </ol>"},{"location":"guides/nrf802154-sniffer/installation/#installing-the-nrf-sniffer-capture-plugin-in-wireshark","title":"Installing the nRF Sniffer capture plugin in Wireshark","text":"<p>The nRF Sniffer for 802.15.4 software sends commands to the nRF Sniffer hardware through the serial port and reads the captured frames. The software can be installed as an external capture plugin in Wireshark. You need to install the plugin only if you plan to use the nRF Sniffer as a Wireshark capture interface.</p> <p>To install the nRF Sniffer capture plugin, complete the following steps:</p> <ol> <li> <p>Install the Python requirements:</p> <ol> <li>Open a command window in the <code>tools/nrf802154_sniffer/</code> folder.</li> <li> <p>Install the Python dependencies listed in <code>requirements.txt</code> by doing one of the following:</p> Windows with Python launcherWindows without Python launcherLinux/macOS <pre><code> py -3 -m pip install -r requirements.txt\n</code></pre> <pre><code>python -m pip install -r requirements.txt\n</code></pre> <pre><code>python3 -m pip install -r requirements.txt\n</code></pre> </li> <li> <p>Close the command window.</p> </li> </ol> </li> <li> <p>Copy the Sniffer capture plugin into Wireshark's folder for external capture plugins:</p> <ol> <li>Open Wireshark.</li> <li> <p>Go to Help &gt; About Wireshark (on Windows or Linux) or Wireshark &gt; About Wireshark (on macOS).</p> <p></p> </li> <li> <p>Select the Folders tab.</p> </li> <li> <p>Double-click the location for the Personal Extcap path to open this folder.</p> <p></p> </li> <li> <p>Copy the following files from the <code>tools/nrf802154_sniffer/nrf802154_sniffer</code> folder into this folder:</p> WindowsLinux/macOS <ul> <li><code>nrf802154_sniffer.py</code></li> <li><code>nrf802154_sniffer.bat</code></li> </ul> <ul> <li><code>nrf802154_sniffer.py</code></li> <li><code>nrf802154_sniffer.sh</code></li> </ul> </li> </ol> </li> <li> <p>Make sure that the nRF Sniffer files run correctly:</p> <ol> <li>Open a command window in Wireshark's folder for personal external capture plugins.</li> <li> <p>Run the Sniffer tool to list available interfaces.</p> WindowsLinux/macOS <pre><code>nrf802154_sniffer.bat --extcap-interfaces\n</code></pre> <pre><code>./nrf802154_sniffer.sh --extcap-interfaces\n</code></pre> <p>You should see a series of strings, similar to what is shown in the following:</p> <pre><code>extcap {version=0.7.2}{help=https://github.com/NordicSemiconductor/nRF-Sniffer-for-802.15.4}{display=nRF Sniffer for 802.15.4}\ncontrol {number=6}{type=button}{role=logger}{display=Log}{tooltip=Show capture log}\n</code></pre> </li> </ol> </li> <li> <p>Refresh the interfaces in Wireshark by selecting Capture &gt; Refresh Interfaces or pressing F5.</p> <p>You should see that nRF Sniffer for 802.15.4 is displayed as one of the interfaces on the start screen.</p> <p></p> </li> </ol>"},{"location":"guides/python/","title":"Code in Python","text":""},{"location":"guides/python/#introduction","title":"Introduction","text":"<p>Python is a high-level programming language which means it's designed to be easier to read, write and maintain. It has a built-in interpreter which means there are no extra steps, like compiling, to get your code to work.</p> <p>nRF52840 Connect Kit can run CircuitPython which allows you to access hardware-specific functionality and peripherals with Python programming language. With CircuitPython, there are no upfront desktop downloads needed. Once you get your board set up, open any text editor, and start editing code. It's that simple.</p> <p>Why CircuitPython?</p> <p>CircuitPython is based on MicroPython and features unified Python core APIs and a growing list of 300+ device libraries and drivers that work with it. See differences from MicroPython.</p>"},{"location":"guides/python/#get-involved","title":"Get Involved","text":"<p>We think the best way to learn is by doing. And to help you get started, we have provided an extensive set of documentation. Find the details below:</p> <ul> <li>Getting started with CircuitPython</li> <li>Samples<ul> <li>Blinky</li> <li>Button</li> <li>ADC</li> <li>PWM</li> <li>USB HID Keyboard</li> <li>USB HID Mouse</li> <li>BLE Advertising</li> <li>BLE Nordic UART Service</li> <li>BLE HID Keyboard</li> <li>BLE HID Mouse</li> </ul> </li> <li>Reference</li> </ul>"},{"location":"guides/python/getting-started/","title":"Getting started with CircuitPython","text":"<p>This section of the documentation takes you through getting up and running with CircuitPython on nRF52840 Connect Kit.</p>"},{"location":"guides/python/getting-started/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/getting-started/#installing-circuitpython","title":"Installing CircuitPython","text":"<p>The pre-built CircuitPython firmware in <code>.uf2</code>-format is located in <code>firmware/circuitpython/</code>.</p> <p>Download the latest firmware and complete the following steps to flash the firmware:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop <code>circuitpython-nrf52840_connectkit-en_US-&lt;version&gt;.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and CircuitPython will start running. It will mount as a Mass Storage Device called CIRCUITPY.</p> </li> </ol> <p></p>"},{"location":"guides/python/getting-started/#coding-with-mu-editor","title":"Coding with Mu Editor","text":"<p>Mu Editor is a simple Python code editor for beginner programmers. Go to Mu Editor Download page, choose your operating system and follow the instructions to install the latest Mu Editor.</p> <p>Start Mu Editor, click Mode on Top Menu. You will be prompted to Select Mode. Select CircuitPython and click OK.</p> <p></p> <p>In the text editor, try some Python code:</p> <pre><code>print('Hello, CircuitPython!')\n</code></pre> <p>Click Save on Top Menu. A window will appear. Give the name <code>code.py</code> for your code and save it onto the CIRCUITPY drive. Your code will run as soon as the file is done saving.</p> <p>Click Serial on Top Menu to open a serial data connection to the board. This will result in a new pane between the text editor and Mu\u2019s footer, which prints the data from the board. </p> <p></p>"},{"location":"guides/python/getting-started/#using-circuitpython-repl","title":"Using CircuitPython REPL","text":"<p>The CircuitPython REPL (Read-Evaluate-Print-Loop) allows you to enter individual lines of code and have them run immediately. It's really handy if you're running into trouble with a particular program and can't figure out why. It's interactive so it's great for testing new ideas.</p> <p>To use the REPL, you first need to be connected to the serial console. Here are the common ways you can use to establish a serial connection:</p> Using Mu EditorRunning <code>screen</code>Using PuTTY <p>Mu Editor has a Serial Console, which can be used to interact with CircuitPython REPL.</p> <p>Click Serial on the Mu Editor's Top Menu to open a serial data connection to the board. This will result in a new pane between the text editor and Mu\u2019s footer: </p> <pre><code>Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\nHello, CircuitPython!\n\nCode done running.\n\nPress any key to enter the REPL. Use CTRL-D to reload.\n</code></pre> <p>On macOS/Linux, you can open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Where <code>&lt;serial-port-name&gt;</code> is the correct serial port that your computer uses to communicate with the board.</p> <p>On Windows, you can use PuTTY to interact with CircuitPython REPL. </p> <p>Start PuTTY, configure the correct serial port and click Open:</p> <p></p> <p>Where <code>&lt;serial-port-name&gt;</code> is the correct serial port that your computer uses to communicate with the board.</p> <p>Once that connection has been established, type CTRL + C to drop into the REPL.</p> <p>Try to write some Python code in the REPL, then press Enter :</p> <pre><code>&gt;&gt;&gt; print('Hello, CircuitPython!')\n&gt;&gt;&gt; Hello, CircuitPython!\n</code></pre> <p>Return to the Serial Console</p> <p>When you're ready to leave the REPL and return to the serial console, simply press CTRL + D . This will reload your board and reenter the serial console. You will restart the program you had running before entering the REPL.</p>"},{"location":"guides/python/reference/","title":"Reference","text":"<p>CircuitPython provides a variety of modules that can be used in your sample applications.</p> <p>Here you can find documentation for these modules, including API reference.</p> Module Description <code>_bleio</code> Bluetooth Low Energy (BLE) communication <code>_pixelmap</code> A fast pixel mapping library <code>adafruit_ble</code> Higher-level Bluetooth Low Energy functionality, building on the native <code>_bleio</code> module <code>adafruit_bus_device</code> Hardware accelerated external bus access <code>adafruit_hid</code> USB Human Interface Device (HID) class <code>adafruit_pixelbuf</code> A fast RGB(W) pixel buffer library for like NeoPixel and DotStar <code>aesio</code> AES encryption routines <code>alarm</code> Alarms and sleep <code>analogio</code> Analog hardware support <code>array</code> Arrays of numeric data <code>atexit</code> Atexit Module <code>audiobusio</code> Support for audio input and output over digital buses <code>audiocore</code> Support for audio samples <code>audiomixer</code> Support for audio mixing <code>audiomp3</code> Support for MP3-compressed audio files <code>audiopwmio</code> Audio output via digital PWM <code>binascii</code> Binary/ASCII conversions <code>bitbangio</code> Digital protocols implemented by the CPU <code>bitmaptools</code> Collection of bitmap manipulation tools <code>board</code> Board specific pin names <code>builtins</code> Builtin functions and exceptions <code>busio</code> Hardware accelerated external bus access <code>collections</code> Collection and container types <code>countio</code> Support for edge counting <code>digitalio</code> Basic digital pin support <code>displayio</code> Native helpers for driving displays <code>errno</code> System error codes <code>fontio</code> Core font related data structures <code>framebufferio</code> Native framebuffer display driving <code>gc</code> Control the garbage collector <code>getpass</code> Getpass Module <code>io</code> Input/output streams <code>json</code> JSON encoding and decoding <code>keypad</code> Support for scanning keys and key matrices <code>math</code> Mathematical functions <code>microcontroller</code> Pin references and cpu functionality <code>micropython</code> Access and control MicroPython internals <code>msgpack</code> Pack object in msgpack format <code>neopixel</code> Higher level NeoPixel driver that presents the strip as a sequence <code>neopixel_write</code> Low-level neopixel implementation <code>nvm</code> Non-volatile memory <code>onewireio</code> Low-level bit primitives for Maxim (formerly Dallas Semi) one-wire protocol <code>os</code> Functions that an OS normally provides <code>paralleldisplay</code> Native helpers for driving parallel displays <code>pulseio</code> Support for individual pulse based protocols <code>pwmio</code> Support for PWM based protocols <code>rainbowio</code> Rainbowio Module <code>random</code> Pseudo-random numbers and choices <code>re</code> Simple regular expressions <code>rgbmatrix</code> Low-level routines for bitbanged LED matrices <code>rotaryio</code> Support for reading rotation sensors <code>rtc</code> Real Time Clock <code>sdcardio</code> Interface to an SD card via the SPI bus <code>select</code> Wait for events on a set of streams <code>sharpdisplay</code> Support for Sharp Memory Display framebuffers <code>storage</code> Storage management <code>struct</code> Manipulation of C-style data <code>supervisor</code> Supervisor settings <code>synthio</code> Support for MIDI synthesis <code>sys</code> System specific functions <code>terminalio</code> Displays text in a TileGrid <code>time</code> Time and timing related functions <code>touchio</code> Touch related IO <code>traceback</code> Traceback Module <code>ulab</code> Manipulate numeric data similar to numpy <code>usb_cdc</code> USB CDC Serial streams <code>usb_hid</code> USB Human Interface Device <code>usb_midi</code> MIDI over USB <code>vectorio</code> Lightweight 2D shapes for displays <code>watchdog</code> Watchdog Timer <code>zlib</code> zlib decompression functionality"},{"location":"guides/python/samples/adc/","title":"ADC","text":"<p>The ADC sample demonstrates using the <code>analogio</code> module to measure the voltage of the device power supply.</p> <p>The measurement circuit contains a voltage divider made of two resistors. AIN0 (alias A0) measures the voltage over the lower resistor and P1.14 (alias MEAS_EN) is used to enable the voltage measurement. The voltage measurement circuitry is shown in the following figure:</p> <p></p>"},{"location":"guides/python/samples/adc/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/adc/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport digitalio\nfrom analogio import AnalogIn\n# Enable measurement\nmeas_en = digitalio.DigitalInOut(board.MEAS_EN)\nmeas_en.direction=digitalio.Direction.OUTPUT\nmeas_en.value = True\n# Analog In \nanalog_in = AnalogIn(board.A0)\n# Measure the voltage of VSYS\ndef get_voltage(ain):\nreturn ((ain.value * 3.3) / 65536) * (1000 + 100) / 100\nwhile True:\nprint((get_voltage(analog_in),))\ntime.sleep(0.1)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Click Serial on Mu Editor's Top Menu to open a serial console. You should see the console output, similar to what is shown in the following:</p> <pre><code>Code stopped by auto-reload. Reloading soon.\n\nAuto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\n(5.149,)\n(5.30852,)\n(5.10468,)\n(5.09582,)\n(5.11355,)\n(5.37942,)\n(5.4769,)\n(5.18444,)\n(5.11355,)\n...\n</code></pre> </li> <li> <p>You can also use the plotter for data inspection. Click Plotter on Mu Editor's Top Menu to open up a plotter pane:</p> <p></p> </li> </ol>"},{"location":"guides/python/samples/blinky/","title":"Blinky","text":""},{"location":"guides/python/samples/blinky/#overview","title":"Overview","text":"<p>The Blinky sample is a simple application which blinks an LED forever using the <code>digitalio</code> module. The source code shows how to configure the LED, then turn it on and off.</p> <p>The table below shows the available LEDs on the nRF52840 Connect Kit:</p> LED Alias Green LED <code>LED0</code> RGB LED - Red <code>LED1</code> or <code>RED_LED</code> RGB LED - Green <code>LED2</code> or <code>GREEN_LED</code> RGB LED - Blue <code>LED3</code> or <code>BLUE_LED</code>"},{"location":"guides/python/samples/blinky/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/blinky/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport digitalio\nimport board\n# Green LED\nled = digitalio.DigitalInOut(board.LED0)\nled.direction = digitalio.Direction.OUTPUT\nwhile True:\nled.value = True\ntime.sleep(0.1)\nled.value = False\ntime.sleep(0.1)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Observe that the Green LED starts to blink.</p> </li> </ol>"},{"location":"guides/python/samples/button/","title":"Button","text":""},{"location":"guides/python/samples/button/#overview","title":"Overview","text":"<p>The Button sample demonstrates the use of GPIO input using the <code>digitalio</code> module. It prints a message to the console each time the state of the button changes.</p> <p>The table below shows the available button on the nRF52840 Connect Kit:</p> Button Alias USER Button <code>USER</code>"},{"location":"guides/python/samples/button/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/button/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import board\nimport digitalio\n# User Button\nbutton = digitalio.DigitalInOut(board.USER)\nbutton.direction = digitalio.Direction.INPUT\nbutton.pull = digitalio.Pull.UP\nlast_value = button.value\nwhile True:\nif last_value != button.value:\nlast_value = button.value\nprint('Button is ' + ('released' if button.value else 'pressed'))\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Click Serial on Mu Editor's Top Menu to open a serial console. Observe the output of the console and press the USER button. You should see the output, similar to what is shown in the following:</p> <pre><code>Code stopped by auto-reload. Reloading soon.\n\nAuto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\nButton is pressed\nButton is released\nButton is pressed\nButton is released\n...\n</code></pre> </li> </ol>"},{"location":"guides/python/samples/pwm/","title":"PWM","text":""},{"location":"guides/python/samples/pwm/#overview","title":"Overview","text":"<p>The PWM sample demonstrates using the <code>pwmio</code> module to fade the Green LED (alias LED0) on nRF52840 Connect Kit.</p>"},{"location":"guides/python/samples/pwm/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/pwm/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport pwmio\n# Connect LED0 to PWMOut\nled = pwmio.PWMOut(board.LED0, frequency=5000, duty_cycle=0)\nwhile True:\nfor i in range(100):\n# PWM LED up and down\nif i &lt; 50:\nled.duty_cycle = int(i * 2 * 65535 / 100)  # Up\nelse:\nled.duty_cycle = 65535 - int((i - 50) * 2 * 65535 / 100)  # Down\ntime.sleep(0.01)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Observe that the Green LED starts off increases its brightness until it is fully on and then decreases until the LED is off, completing on fade cycle.</p> </li> </ol>"},{"location":"guides/python/samples/ble/advertising/","title":"BLE Advertising","text":""},{"location":"guides/python/samples/ble/advertising/#overview","title":"Overview","text":"<p>The BLE Advertising sample demonstrates the BLE Advertising functionality using the <code>adafruit_ble</code> module.</p> <p>When the code starts, nRF52840 Connect Kit will advertise with its name.</p> <p>Tip</p> <p><code>adafruit_ble</code> is pre-built into CircuitPython as a frozen module, so that it can be imported in the code directly.</p>"},{"location":"guides/python/samples/ble/advertising/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with nRF Connect for Mobile installed</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/ble/advertising/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>from adafruit_ble import BLERadio\nfrom adafruit_ble.advertising import Advertisement\nble = BLERadio()\nble.name = \"nRF52840 Connect Kit\"\nadvertisement = Advertisement()\nadvertisement.complete_name = ble.name\nadvertisement.connectable = True\nwhile True:\nprint(advertisement)\nble.start_advertising(advertisement)\nwhile not ble.connected:\npass\nprint(\"connected\")\nwhile ble.connected:\npass\nprint(\"disconnected\")\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Start the nRF Connect for Mobile app, scan the device and observe that the board is advertising with the Device Name <code>nRF52840 Connect Kit</code>.</p> <p></p> </li> </ol>"},{"location":"guides/python/samples/ble/hid_keyboard/","title":"BLE HID Keyboard","text":""},{"location":"guides/python/samples/ble/hid_keyboard/#overview","title":"Overview","text":"<p>The BLE HID Keyboard sample demonstrates how to use the GATT Human Interface Device (HID) Service to implement a keyboard input device that you can connect to your computer.</p> <p>This sample code enumerates the nRF52840 Connect Kit into a BLE HID keyboard that has an A key connected to the USER button.</p> <p>Tip</p> <p><code>adafruit_ble</code> and <code>adafruit_hid</code> are pre-built into CircuitPython as frozen modules, so that they can be imported in the code directly.</p>"},{"location":"guides/python/samples/ble/hid_keyboard/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer, with Bluetooth LE supported</li> </ul>"},{"location":"guides/python/samples/ble/hid_keyboard/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import board\nimport digitalio\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nfrom adafruit_hid.keycode import Keycode\nimport adafruit_ble\nfrom adafruit_ble.advertising import Advertisement\nfrom adafruit_ble.advertising.standard import ProvideServicesAdvertisement\nfrom adafruit_ble.services.standard.hid import HIDService\nfrom adafruit_ble.services.standard.device_info import DeviceInfoService\n# USER button acts as A key on a keyboard\nkey_a = digitalio.DigitalInOut(board.USER)\nkey_a.direction = digitalio.Direction.INPUT\nkey_a.pull = digitalio.Pull.UP\n# LED0 indicates A key is pressed\nled = digitalio.DigitalInOut(board.LED0)\nled.direction = digitalio.Direction.OUTPUT\nled.value = True\n# Use default HID descriptor\nhid = HIDService()\ndevice_info = DeviceInfoService(\nsoftware_revision=adafruit_ble.__version__, manufacturer=\"Makerdiary\"\n)\nble = adafruit_ble.BLERadio()\nble.name = 'CIRCUITPY KEYBOARD'\nadvertisement = ProvideServicesAdvertisement(hid)\nadvertisement.complete_name = ble.name\nadvertisement.appearance = 961\nscan_response = Advertisement()\nif ble.connected:\nfor c in ble.connections:\nc.disconnect()\nprint(\"advertising\")\nble.start_advertising(advertisement, scan_response)\nkeyboard = Keyboard(hid.devices)\nwhile True:\nwhile not ble.connected:\npass\nwhile ble.connected:\nif not key_a.value:\nprint(\"Key A pressed!\")\n# Turn on LED0\nled.value = False\nwhile not key_a.value:\npass    # Wait for key A released\n# Type keycode `Shift+A`\nkeyboard.press(Keycode.SHIFT, Keycode.A)\nkeyboard.release_all()\n# Turn off LED0\nled.value = True\nble.start_advertising(advertisement)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. A Bluetooth keyboard with the name <code>CIRCUITPY KEYBOARD</code> can be discovered by your computer. Connect to the keyboard.</p> <p></p> </li> <li> <p>Open a text editor and press USER button on the board. Every button press sends a character <code>A</code> to your computer, and this will be displayed in the text editor.</p> </li> </ol>"},{"location":"guides/python/samples/ble/hid_mouse/","title":"BLE HID Mouse","text":""},{"location":"guides/python/samples/ble/hid_mouse/#overview","title":"Overview","text":"<p>The BLE HID Mouse sample demonstrates how to use the GATT Human Interface Device (HID) Service to implement a mouse input device that you can connect to your computer.</p> <p>This sample code enumerates the nRF52840 Connect Kit into a BLE HID mouse that has a left button connected to the USER button.</p> <p>Tip</p> <p><code>adafruit_ble</code> and <code>adafruit_hid</code> are pre-built into CircuitPython as frozen modules, so that they can be imported in the code directly.</p>"},{"location":"guides/python/samples/ble/hid_mouse/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer, with Bluetooth LE supported</li> </ul>"},{"location":"guides/python/samples/ble/hid_mouse/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport digitalio\nfrom adafruit_hid.mouse import Mouse\nimport adafruit_ble\nfrom adafruit_ble.advertising import Advertisement\nfrom adafruit_ble.advertising.standard import ProvideServicesAdvertisement\nfrom adafruit_ble.services.standard.hid import HIDService\nfrom adafruit_ble.services.standard.device_info import DeviceInfoService\nleft_button = digitalio.DigitalInOut(board.USER)\nleft_button.direction = digitalio.Direction.INPUT\nleft_button.pull = digitalio.Pull.UP\n# Use default HID descriptor\nhid = HIDService()\ndevice_info = DeviceInfoService(\nsoftware_revision=adafruit_ble.__version__, manufacturer=\"Makerdiary\"\n)\nble = adafruit_ble.BLERadio()\nble.name = 'CIRCUITPY MOUSE'\nadvertisement = ProvideServicesAdvertisement(hid)\nadvertisement.complete_name = ble.name\nadvertisement.appearance = 962\nscan_response = Advertisement()\nif ble.connected:\nfor c in ble.connections:\nc.disconnect()\nprint(\"advertising\")\nble.start_advertising(advertisement, scan_response)\nmouse = Mouse(hid.devices)\nwhile True:\nwhile not ble.connected:\npass\nwhile ble.connected:\nif left_button.value is False:\nmouse.click(Mouse.LEFT_BUTTON)\ntime.sleep(0.2)  # Debounce delay\nble.start_advertising(advertisement)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. A Bluetooth mouse with the name <code>CIRCUITPY MOUSE</code> can be discovered by your computer. Connect to the mouse.</p> <p></p> </li> <li> <p>Press USER button on the board, and observe that a left mouse click is activated.</p> </li> </ol>"},{"location":"guides/python/samples/ble/nus/","title":"BLE Nordic UART Service","text":""},{"location":"guides/python/samples/ble/nus/#overview","title":"Overview","text":"<p>The BLE Nordic UART Service sample demonstrates using Nordic UART Service to control the RGB LED on nRF52840 Connect Kit over Bluetooth Low Energy.</p> <p>Tip</p> <p><code>adafruit_ble</code> is pre-built into CircuitPython as a frozen module, so that it can be imported in the code directly.</p>"},{"location":"guides/python/samples/ble/nus/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>A smartphone or a tablet with nRF Toolbox installed</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/ble/nus/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import digitalio\nimport board\nfrom adafruit_ble import BLERadio\nfrom adafruit_ble.advertising.standard import ProvideServicesAdvertisement\nfrom adafruit_ble.services.nordic import UARTService\nred_led = digitalio.DigitalInOut(board.RED_LED)\nred_led.direction = digitalio.Direction.OUTPUT\nred_led.value = True\ngreen_led = digitalio.DigitalInOut(board.GREEN_LED)\ngreen_led.direction = digitalio.Direction.OUTPUT\ngreen_led.value = True\nblue_led = digitalio.DigitalInOut(board.BLUE_LED)\nblue_led.direction = digitalio.Direction.OUTPUT\nblue_led.value = True\nble = BLERadio()\nble.name = \"CIRCUITPY NUS\"\nuart = UARTService()\nadvertisement = ProvideServicesAdvertisement(uart)\nwhile True:\nble.start_advertising(advertisement)\nwhile not ble.connected:\npass\nwhile ble.connected:\n# Returns b'' if nothing was read.\none_byte = uart.read(1)\nif one_byte == b'1':\nred_led.value = not red_led.value\nelif one_byte == b'2':\ngreen_led.value = not green_led.value\nelif one_byte == b'3':\nblue_led.value = not blue_led.value\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. Start the nRF Toolbox app, tap UART to open the UART application.</p> </li> <li>Connect to the device with the name <code>CIRCUITPY NUS</code> discovered in the UART application.</li> <li> <p>Tap the blank buttons to create new commands. The following command assignments are configured with EOL set to LF :</p> <ul> <li> - Send <code>1</code> to toggle the RED LED.</li> <li> - Send <code>2</code> to toggle the GREEN LED.</li> <li> - Send <code>3</code> to toggle the BLUE LED.</li> </ul> <p> </p> </li> <li> <p>Tap   to toggle the RGB LED. Observe that the RGB LED on the board turns on or off.</p> </li> </ol>"},{"location":"guides/python/samples/usb/hid_keyboard/","title":"USB HID Keyboard","text":""},{"location":"guides/python/samples/usb/hid_keyboard/#overview","title":"Overview","text":"<p>The USB HID Keyboard sample demonstrates using the USB Human Interface Device (HID) module to implement a keyboard input device that you can connect to your computer.</p> <p>This sample code enumerates the nRF52840 Connect Kit into a HID keyboard that has an A key connected to the USER button.</p> <p>Tip</p> <p><code>adafruit_hid</code> is pre-built into CircuitPython as a frozen module, so that it can be imported in the code directly.</p>"},{"location":"guides/python/samples/usb/hid_keyboard/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/usb/hid_keyboard/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport digitalio\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nfrom adafruit_hid.keycode import Keycode\n# USER button acts as A key on a keyboard\nkey_a = digitalio.DigitalInOut(board.USER)\nkey_a.direction = digitalio.Direction.INPUT\nkey_a.pull = digitalio.Pull.UP\n# LED0 indicates A key is pressed\nled = digitalio.DigitalInOut(board.LED0)\nled.direction = digitalio.Direction.OUTPUT\n# The keyboard object!\ntime.sleep(1)  # Sleep for a bit to avoid a race condition on some systems\nkeyboard = Keyboard(usb_hid.devices)\nkeyboard_layout = KeyboardLayoutUS(keyboard)\nprint(\"Waiting for key pin...\")\nwhile True:\nif not key_a.value:\nprint(\"Key A pressed!\")\n# Turn on LED0\nled.value = False\nwhile not key_a.value:\npass    # Wait for key A released\n# Type keycode `Shift+A`\nkeyboard.press(Keycode.SHIFT, Keycode.A)\nkeyboard.release_all()\n# Turn off LED0\nled.value = True\ntime.sleep(0.01)\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. The board will enumerate as a HID keyboard. Click Serial on Mu Editor's Top Menu to open a serial console. You should see the console output, similar to what is shown in the following:</p> <pre><code>Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\ncode.py output:\nWaiting for key pin...\n</code></pre> </li> <li> <p>Open a text editor and press USER button on the board. Every button press sends a character <code>A</code> to the computer, and this will be displayed in the text editor.</p> </li> </ol>"},{"location":"guides/python/samples/usb/hid_mouse/","title":"USB HID Mouse","text":""},{"location":"guides/python/samples/usb/hid_mouse/#overview","title":"Overview","text":"<p>The USB HID Mouse sample demonstrates using the USB Human Interface Device (HID) module to implement a mouse input device that you can connect to your computer.</p> <p>This sample code enumerates the nRF52840 Connect Kit into a HID mouse that has a left button connected to the USER button.</p> <p>Tip</p> <p><code>adafruit_hid</code> is pre-built into CircuitPython as a frozen module, so that it can be imported in the code directly.</p>"},{"location":"guides/python/samples/usb/hid_mouse/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>nRF52840 Connect Kit running the CircuitPython firmware</li> <li>1x USB-C Cable</li> <li>Mu Editor</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> </ul>"},{"location":"guides/python/samples/usb/hid_mouse/#running-the-code","title":"Running the code","text":"<p>To run the code, complete the following steps:</p> <ol> <li>Connect nRF52840 Connect Kit to your computer using the USB-C Cable.</li> <li>Start Mu Editor, click Load to open <code>code.py</code> in the CIRCUITPY drive.</li> <li> <p>Copy and paste the following code into <code>code.py</code> and click Save:</p> CIRCUITPY/code.py<pre><code>import time\nimport board\nimport digitalio\nimport usb_hid\nfrom adafruit_hid.mouse import Mouse\nmouse = Mouse(usb_hid.devices)\nleft_button = digitalio.DigitalInOut(board.USER)\nleft_button.direction = digitalio.Direction.INPUT\nleft_button.pull = digitalio.Pull.UP\nwhile True:\nif left_button.value is False:\nmouse.click(Mouse.LEFT_BUTTON)\ntime.sleep(0.2)  # Debounce delay\n</code></pre> </li> <li> <p>Your code will run as soon as the file is done saving. The board will enumerate as a HID mouse. Press USER button on the board, and observe that a left mouse click is activated.</p> </li> </ol>"},{"location":"programming/","title":"How to program the nRF52840 Connect Kit","text":"<p>nRF52840 Connect Kit is shipped with the UF2 Bootloader, which is an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the <code>.uf2</code>-format images to the flash drive.</p> <p>Alternatively, you can update the firmware by using DAPLink on another nRF52840 Connect Kit or using Pitaya-Link debug probe.</p> <ul> <li>Using the UF2 Bootloader</li> <li>Using DAPLink on nRF52840 Connect Kit</li> <li>Using Pitaya-Link debug probe</li> </ul>"},{"location":"programming/daplink/","title":"Using DAPLink on nRF52840 Connect Kit","text":"<p>One nRF52840 Connect Kit can be used to reprogram and debug another, using the DAPLink interface firmware, which creates a bridge between your development computer and the target's debug access port.</p>"},{"location":"programming/daplink/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>2x nRF52840 Connect Kit</li> <li>1x USB-C Cable</li> <li>Several jumper wires</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> <li>Python 3.6.0 or later</li> <li>pyOCD - Python based tool and API for debugging, programming, and exploring Arm Cortex microcontrollers.</li> </ul>"},{"location":"programming/daplink/#programming-the-daplink-firmware","title":"Programming the DAPLink firmware","text":"<p>You must program the DAPLink firmware onto a nRF52840 Connect Kit to make it become a CMSIS-DAP debug probe. The latest DAPLink firmware is located in the <code>firmware/daplink</code> folder.</p> <p>To program the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> </li> <li> <p>Drag and drop the firmware with the name <code>daplink-nrf52840_connectkit-&lt;version&gt;.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board, the DAPLink firmware is running and a disk drive called DAPLINK will be automatically detected by the computer.</p> </li> </ol>"},{"location":"programming/daplink/#installing-pyocd","title":"Installing pyOCD","text":"<p>The latest stable version of pyOCD may be installed via pip. Open up a terminal and run:</p> WindowsLinux/macOS <pre><code>py -3 -m pip install -U pyocd\n</code></pre> <pre><code>python3 -m pip install -U pyocd\n</code></pre>"},{"location":"programming/daplink/#wiring-the-boards","title":"Wiring the boards","text":"<p>Perform the following steps to connect the boards:</p> <ol> <li>Connect the DAPLink board to the target board using the jumper wires.</li> <li>Connect the DAPLink board to the PC using the USB-C Cable.</li> </ol> <p></p> <p>The following table shows the signals between the DAPLink and the target:</p> DAPLink Wire Target <code>3V3</code> <code>VSYS</code> <code>GND</code> <code>GND</code> <code>P12</code> <code>RESET</code> <code>P13</code> <code>SWDCLK</code> <code>P14</code> <code>SWDIO</code>"},{"location":"programming/daplink/#drag-and-drop-programming","title":"Drag-and-drop programming","text":"<p>Drag-and-drop is an optional intuitive programming feature of DAPLink. It allows programming of your target microcontroller in a very simple way: dragging and dropping a file (<code>.hex</code>-format) onto the DAPLINK drive.</p> <p></p>"},{"location":"programming/daplink/#using-pyocd","title":"Using pyOCD","text":"<p>The <code>pyocd</code> command line tool gives you total control over your device with these subcommands:</p> <ul> <li><code>gdbserver</code>: GDB remote server allows you to debug using gdb via either the console or several GUI debugger options.</li> <li><code>load</code>: Program files of various formats into flash or RAM.</li> <li><code>erase</code>: Erase part or all of an MCU's flash memory.</li> <li><code>pack</code>: Manage CMSIS Device Family Packs that provide additional target device support.</li> <li><code>commander</code>: Interactive REPL control and inspection of the MCU.</li> <li><code>server</code>: Share a debug probe with a TCP/IP server.</li> <li><code>reset</code>: Hardware or software reset of a device.</li> <li><code>rtt</code>: Stream Segger RTT IO with any debug probe.</li> <li><code>list</code>: Show connected devices.</li> </ul> <p>You can get additional help by adding <code>--help</code> option.</p> <p>To load/erase the nRF52840 Connect Kit target, open up a terminal and run:</p> Load <code>.hex</code>Load <code>.bin</code>Chip Erase <pre><code>pyocd load -t nrf52840 firmware.hex\n</code></pre> <pre><code>pyocd load -t nrf52840 --base-address 0x1000 firmware.bin\n</code></pre> <pre><code>pyocd erase -t nrf52840 --chip\n</code></pre>"},{"location":"programming/daplink/#explore-further","title":"Explore further","text":"<p>To learn more about pyOCD, check the pyOCD Documentation.</p>"},{"location":"programming/pitaya-link/","title":"Using Pitaya-Link debug probe","text":"<p>Pitaya-Link is a low-cost debug probe based on the CMSIS-DAP (also known as DAPLink) protocol standard. It can be used to program and debug the application software running on Arm Cortex Microcontrollers.</p> <p>This section details how to program the nRF52840 Connect Kit using Pitaya-Link debug probe. Refer to the Pitaya-Link User's Guide for more details.</p>"},{"location":"programming/pitaya-link/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF52840 Connect Kit</li> <li>1x Pitaya-Link debug probe</li> <li>1x USB-C Cable</li> <li>Several jumper wires</li> <li>A computer running macOS, Linux, or Windows 7 or newer</li> <li>Python 3.6.0 or later</li> <li>pyOCD - Python based tool and API for debugging, programming, and exploring Arm Cortex microcontrollers.</li> </ul>"},{"location":"programming/pitaya-link/#installing-pyocd","title":"Installing pyOCD","text":"<p>The latest stable version of pyOCD may be installed via pip. Open up a terminal and run:</p> WindowsLinux/macOS <pre><code>py -3 -m pip install -U pyocd\n</code></pre> <pre><code>python3 -m pip install -U pyocd\n</code></pre>"},{"location":"programming/pitaya-link/#wiring-the-boards","title":"Wiring the boards","text":"<p>Perform the following steps to connect the boards:</p> <ol> <li>Connect Pitaya-Link to the target board using the jumper wires.</li> <li>Connect Pitaya-Link to the PC using the USB-C Cable.</li> </ol> <p></p> <p>The following table shows the signals between Pitaya-Link and nRF52840 Connect Kit:</p> Pitaya-Link Wire nRF52840 Connect Kit <code>3V3</code> <code>VSYS</code> <code>GND</code> <code>GND</code> <code>RESET</code> <code>RESET</code> <code>SWDCLK</code> <code>SWDCLK</code> <code>SWDIO</code> <code>SWDIO</code>"},{"location":"programming/pitaya-link/#drag-and-drop-programming","title":"Drag-and-drop programming","text":"<p>Drag-and-drop is an optional intuitive programming feature of DAPLink. It allows programming of your target microcontroller in a very simple way: dragging and dropping a file (<code>.hex</code>-format) onto the PITAYA-LINK drive.</p> <p></p>"},{"location":"programming/pitaya-link/#using-pyocd","title":"Using pyOCD","text":"<p>The <code>pyocd</code> command line tool gives you total control over your device with these subcommands:</p> <ul> <li><code>gdbserver</code>: GDB remote server allows you to debug using gdb via either the console or several GUI debugger options.</li> <li><code>load</code>: Program files of various formats into flash or RAM.</li> <li><code>erase</code>: Erase part or all of an MCU's flash memory.</li> <li><code>pack</code>: Manage CMSIS Device Family Packs that provide additional target device support.</li> <li><code>commander</code>: Interactive REPL control and inspection of the MCU.</li> <li><code>server</code>: Share a debug probe with a TCP/IP server.</li> <li><code>reset</code>: Hardware or software reset of a device.</li> <li><code>rtt</code>: Stream Segger RTT IO with any debug probe.</li> <li><code>list</code>: Show connected devices.</li> </ul> <p>You can get additional help by adding <code>--help</code> option.</p> <p>To load/erase the nRF52840 Connect Kit target, open up a terminal and run:</p> Load <code>.hex</code>Load <code>.bin</code>Chip Erase <pre><code>pyocd load -t nrf52840 firmware.hex\n</code></pre> <pre><code>pyocd load -t nrf52840 --base-address 0x1000 firmware.bin\n</code></pre> <pre><code>pyocd erase -t nrf52840 --chip\n</code></pre>"},{"location":"programming/uf2boot/","title":"Update firmware using the UF2 Bootloader","text":""},{"location":"programming/uf2boot/#overview","title":"Overview","text":"<p>nRF52840 Connect Kit is shipped with the UF2 Bootloader, which is an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the <code>.uf2</code>-format images to the flash drive without using an external programmer.</p> <p>This section details how to update firmware using the UF2 Bootloader.</p>"},{"location":"programming/uf2boot/#flash-memory-layout","title":"Flash memory layout","text":"<p>When updating firmware using the UF2 Bootloader, you must be aware of where in the device memory the different firmware components are located.</p> <p>The following figure shows the default flash memory layout of nRF52840 Connect Kit:</p> Usage Memory location Size Bootloader settings 0x000FF000 4 KB MBR parameter storage 0x000FE000 4 KB Bootloader config 0x000FD800 2 KB Bootloader 0x000F4000 38 KB Application 0x00001000 972 KB Master Boot Record (MBR) 0x00000000 4 KB"},{"location":"programming/uf2boot/#installing-uf2-converter","title":"Installing UF2 Converter","text":"<p><code>uf2conv</code> is an open source Python based tool for packing and unpacking UF2 files.</p> <p>Before you install <code>uf2conv</code>, make sure that you have Python 3.6.0 or later installed. </p> <p>Then open up a terminal and run the following command to install the latest prerelease version from the HEAD of the main branch:</p> WindowsLinux/macOS <pre><code>py -3 -m pip install --pre -U git+https://github.com/makerdiary/uf2utils.git@main\n</code></pre> <pre><code>python3 -m pip install --pre -U git+https://github.com/makerdiary/uf2utils.git@main\n</code></pre> <p>You can run <code>uf2conv --help</code> for a list of available options:</p> <pre><code>$ uf2conv --help\n\nusage: uf2conv [-h] [-b BASE] [-f FAMILY] [-o FILE] [-d DEVICE_PATH] [-l] [-c] [-D] [-w] [-C] [-i] [INPUT]\nConvert to UF2 or flash directly.\n\npositional arguments:\n  INPUT                 input file (HEX, BIN or UF2)\noptions:\n  -h, --help            show this help message and exit\n-b BASE, --base BASE  set base address of application for BIN format (default: 0x2000)\n-f FAMILY, --family FAMILY\n                        specify familyID - number or name (default: 0x0)\n-o FILE, --output FILE\n                        write output to named file; defaults to \"flash.uf2\" or \"flash.bin\" where sensible\n  -d DEVICE_PATH, --device DEVICE_PATH\n                        select a device path to flash\n  -l, --list            list connected devices\n  -c, --convert         do not flash, just convert\n  -D, --deploy          just flash, do not convert\n  -w, --wait            wait for device to flash\n  -C, --carray          convert binary file to a C array, not UF2\n  -i, --info            display header information from UF2, do not convert\n</code></pre>"},{"location":"programming/uf2boot/#generating-the-firmware-in-uf2","title":"Generating the firmware in UF2","text":"<p>To generate the application firmware in UF2, simply use <code>uf2conv</code> on a <code>.bin</code> file or <code>.hex</code> file, specifying the family as <code>0xADA52840</code>:</p> Generating from <code>.hex</code>Generating from <code>.bin</code> <pre><code>uf2conv -f 0xADA52840 -c -o application.uf2 application.hex\n</code></pre> <pre><code>uf2conv -f 0xADA52840 -c -b 0x1000 -o application.uf2 application.bin\n</code></pre> <p>To generate a UF2 image for bootloader from a <code>.hex</code> file, specifying the separated family of <code>0xD663823C</code>:</p> <pre><code>uf2conv -f 0xD663823C -c -o bootloader.uf2 bootloader.hex\n</code></pre>"},{"location":"programming/uf2boot/#updating-the-application-firmware","title":"Updating the application firmware","text":"<p>Generate the correct UF2 application firmware for your board by following the steps above.</p> <p>To update the application firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT.</p> <p></p> </li> <li> <p>Drag and drop the UF2 file onto the UF2BOOT volume. The RGB LED blinks red fast during flashing.</p> </li> <li> <p>Reset the board and the new application firmware is running.</p> </li> </ol> <p>Enter DFU mode after the board power-up</p> <p>After the board power-up, you can still enter the DFU mode by pressing the RESET button twice within 500 ms.</p>"},{"location":"programming/uf2boot/#updating-the-uf2-bootloader","title":"Updating the UF2 Bootloader","text":"<p>The UF2 Bootloader is self-upgradable, so that you can update the UF2 bootloader without using an external programmer. The latest UF2 bootloader is located in the <code>firmware/uf2_bootloader</code> folder.</p> <p>To update the bootloader, complete the following steps:</p> <ol> <li> <p>Push and hold the USER button and plug your board into the USB port of your computer. Release the USER button after your board is connected. The RGB LED turns green.</p> </li> <li> <p>Open <code>INFO_UF2.TXT</code> in the UF2BOOT volume with a text editor, and check the current version of bootloader. The figure below shows we are running the <code>0.7.0-rtm</code> version.</p> <p></p> </li> <li> <p>Check if newer updates are available in the <code>firmware/uf2_bootloader</code> folder. The update is released with the name <code>update-nrf52840_connectkit-uf2_bootloader-&lt;version&gt;-nosd.uf2</code>.</p> </li> <li> <p>Drag and drop the update file onto the UF2BOOT volume.</p> </li> <li> <p>Enter DFU mode again and verify the version printed in <code>INFO_UF2.TXT</code>.</p> </li> </ol> <p>How to recovery when the UF2 bootloader is broken</p> <p>The only method to recovery from a broken bootloader is using an external debugger to download a fresh <code>.hex</code>-format bootloader. The <code>.hex</code>-format bootloader is also located in the <code>firmware/uf2_bootloader</code> folder. Follow the instructions below for programming:</p> <ul> <li>Using DAPLink on nRF52840 Connect Kit</li> <li>Using Pitaya-Link debug probe</li> </ul>"}]}